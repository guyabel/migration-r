[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Handling, Measuring, Estimating and Visualizing Migration Data in R",
    "section": "",
    "text": "Preface\nIn many countries and regions throughout the world, migration is becoming or already is the largest component of population change and represents an important mechanism for social, economic and environmental change. Migration data, however, are too often of poor quality, missing or provided without disaggregation by basic demographic characteristics such as age and sex. Methods to estimate migration flows have been developed by demographers and other researchers to help address shortfalls of extant population data sources and provide a platform to better understand patterns, trends and consequences of migration dynamics at different geographic scales. This manual considers methods for measuring, estimating and visualising migration flow data between populations, and their implementation using R. Readers will become familiar with useful R functions for handling migration data, a range of measures to summarise and compare migration systems, common estimation methods to overcome inadequate or missing migration data, and recently developed methods to visualize complex migration patterns. Code samples and exercises are provided throughout the manual. While not a requirement, readers would benefit most from these illustrative applications if they have some prior knowledge in how to handle and plot data using the tidyverse set of R packages."
  },
  {
    "objectID": "00-intro.html",
    "href": "00-intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "In many countries and regions throughout the world, human migration represents a major force of demographic, social, economic and environmental change. However, the underlying processes of migration are complex and dynamic. Research concerning these processes are challenged by weak empiric: data on the human population movements at the national, regional and international scales are of poor quality in both validity and reliability. This is especially true for data on international migration. Consequently, examination of the patterns and consequences of migration for social and environmental change is limited. Methods to estimate migration flows developed by demographers and other researchers emerge as critical tools to addressing these shortfalls in data provision and quality. Use of these tools in the analysis of patterns, trends and consequences of migration holds the potential to advance scientific understanding of social and environmental change as well as to inform domains of national, regional and international policy. The goal of this manual is to expand engagement in migration estimation and analysis using effective and robust approaches that are currently available in the public domain.\nThis manual covers a range of methods for handling, measuring, estimating, and visualizing migration data in R. The approach is designed for migration measured at national, regional and international levels. These methods are based on several authoritative sources, including the UN DESA manuals on Methods of measuring internal migration and Preparing migration data for subnational population projections, as well as the migration chapters of the IUSSP Tools for Demographic Estimation. Additionally, recent developments in the population sciences and migration studies are included. By the end of engagement with this manual, you, the reader, will have a comprehensive understanding of the various methods available for working with migration data in R, and how to apply them to empirical research, both academic and policy oriented.\nTo make the most of this manual, we assume that you have basic knowledge of and experience in using R, and in particular, the tidyverse set of R packages. If you are not familiar with R or need a refresher, we recommend working your way through an online course before diving into this manual. Some good resources for learning R and the tidyverse include:\n\nR for Data Science, a comprehensive guide to data science in R, covering data import and cleaning, data visualization, and statistical modeling.\nDataCamp, an online learning platform that offers interactive courses on R programming and data science topics.\nR Bootcamp, a free online course that covers the basics of R programming and the tidyverse.\nTidyverse.org, a website dedicated to the tidyverse packages with tutorials, articles, and other resources for learning and using them.\nSwirl, an interactive learning platform within R that teaches you how to use R in a hands-on manner.\n\nThese resources provide a comprehensive introduction to R programming and the tidyverse, which will be useful throughout this manual and in your future data analysis work.\nThe manual is organized into 11 chapters, each covering a different aspect of migration data analysis at the aggregate level using R. Chapter 2 provides an introduction to migration concepts and definitions. Chapter 3 focuses on the general approach to organizing migration data in R. Chapter 4 covers summary migration measures and indices. Chapter 5 is dedicated to estimating net migration totals. Chapter 6 focuses on describing and estimating migration age structures. Chapter 7 covers methods for describing bilateral migration flows. Chapter 8 covers methods for estimating bilateral migration flows. Chapters 9 and 10 cover methods for visualizing bilateral migration, including chord diagrams and Sankey plots. Finally, the manual ends with a conclusion and discussion of how the methods could be expanded and further developed in Chapter 11.\nIn each chapter, we provide code and data that will allow you to replicate the outputs we present, as well as exercises that will allow you to apply and practice the concepts and methods on your own. Solutions to these exercises are provided so you can check your work and ensure that you have a firm grasp of the material before moving on to the next chapter. By following the examples and completing the exercises in this manual, you will gain a deep understanding of how to handle, measure, estimate, and visualize migration data in R. Exercises have been developed to illustrate the range of possible applications of these tools of migration analysis."
  },
  {
    "objectID": "01-concepts.html#spatial",
    "href": "01-concepts.html#spatial",
    "title": "2  Migration Concepts",
    "section": "2.1 Spatial",
    "text": "2.1 Spatial\n\n2.1.1 Usual Residence\nCentral to the spatial dimension of defining a migration event is the concept of place of residence, used to determine the migrants origin and destination locations. The Principles and Recommendations for Population and Housing Censuses (UN Statistics Division 2008: 102, para. 1.463) defines usual residence as follows:\n\nThe place at which the person has lived continuously for most of the last 12 months (that is, for at least six months and one day), not including temporary absences for holidays or work assignments, or intends to live for at least six months;\nThe place at which the person has lived continuously for at least the last 12 months, not including temporary absences for holidays or work assignments, or intends to live for at least 12 months.\n\nThe use of two alternative criteria leaves some degree of ambiguity, where the subtle differences in each definition has potentially significant implications for the measurement of migration. Further, within either of these criteria they might be additional ambiguity if the migration data source refers to migrant intentions as opposed to the measurement of actual migration behavior: take for example, at the point of data collection, persons on short-term work assignments might have intentions to stay for only a few months, but the actual work assignment may evolve into a longer stay of many months.\nSpatial criteria regarding distance are also included in migration definitions ((Lee1966?)). e Following migration scholarship as well as international statistical recommendations, we advocate generally distinguishing between short distance / local moves, such as within cities or labor markets, and those that are considered longer distance (between cities or labor markets). There are important distinctions to be made between local mobility and migration that make their separation worthwhile: local mobility isdriven primarily by household factors while migration is driven by economic and social network factors. As with temporal criteria for defining migration. spatial criteria will reflect the specific sources of data being used for the analysis of migration which in turn reflect national statistical practices as well as specific research objectives. It is important to note, however, that the methods covered in this manual can be used to analyse and estimate both longer term migration as well as short term mobility.\nCountries with the benefit of population registration systems have the opportunity to measure distance of move directly by comparing address information on points of origin and destination and thus tabulate moves by the distance covered.However, in countries without population registers or the statistical means or (time consuming) resources to tap the potential of registration system, administrative or political units into which the country is divided are often used as proxies for measuring significant distance. Thus, migration is operationally defined as a change of residence from one civil division to another. It is essential to appreciate that the volume of migration is then a function of the size and even shape of areas chosen for compilation, where typically larger administrative units, such as a province or country, have a higher volume of migration compared to smaller units like cities or counties. Using larger geographic units can result in a loss of detail and accuracy in migration data. For instance, if a state is used as the unit of compilation, it may not capture migration patterns between different cities within the state, which could be important for local policy-making. On the other hand, using smaller geographic units such as census tracts may result in too much detail, making it difficult to draw broader conclusions about migration trends at the regional or national level. Most national statistical systems countries typically have hierarchies in their administrative units and provide some internal migration data to reflect one or more of these geographies.\n\n\n2.1.2 Migration Data Types\nA demographic perspective often distinguishes between migration stock and flow. Migration flows are migration events that occur over time and over the course of a person’s life. Flows reflect individual (or household behavior) and, when compared to a ‘population at risk’ of experiencing migration, can be the basis for computing migration rates for a population (to be discussed further in Chapter 4. Population stock, or in our case, migration stock, are characteristics measured at the aggregate level, for example, approximately 3% of the world’s population are international migrants! (again to be discussed below). Each of these migration concepts are best measured using specific data sources.\nThere are two main sources of data on migration flows which data and they, to a large extent, determine the types of migration that are analysed and used in demographic estimation and projections. The two main sources are administrative registers and population registration systems and national census and survey questionnaires. Administrative and population registers measure migration events continuously occurring over time. They record change in residence , analogous to registration of vital events such as births, deaths, marriages, etc. . Thus, the number of persons who have migrated within a year can be calculated as the sum of all recorded moves that occurred in that year. Often there are no duration qualifications so potentially persons can have multiple or return moves within a given year. Censuses and surveys, in contrast, are conducted at essentially one point in time, and generate cross-sectional information on population characteristics. Census and surveys , typically have retrospective questions on place of usual residence that can be cross tabulated with questions on place(s) of residence at a previous time, usually one or five years prior to the time of the census or survey. . Cross tabulations between place of residence one or five years ago with place of current residence represent migrant transitions. With these data, we do not know the exact date of the move, only that a move has occurred between two points in time. We do not know whether the move occurred 10 months ago or one week ago. Migrations followed by return within the same interval, in this example, five years, will be mixed in retrospective questions.Other types of migration data are occasionally collected in census and survey instruments that do not involve the origin location of a migration, including the duration at residence, number of moves over a given interval, and country of citizenship.\nLifetime migration data is another common type of migration data that can be generated from both administrative and population registers and cross-sectional data - censuses and surveys. . Similar to migrant transition data described above, lifetime migration is measured through cross tabulation between current place of usual residence and original place of birth. However, these data are not considered a type of flow data. Instead, they are considered migrant population stock data, and constitute a population characteristic at one point in time. With these data, we do not know a time or period when the person migrated or how often and where, only that they have migrated at least once since birth. Of course, only persons surviving to the time of the census or survey would be included. In spite of these pitfalls, national censuses in particular and surveys are critical sources of data on migration and are critical to comparative analysis of migration among populations. For the measurement of international migration, stock data have been gathered and tabulated from most countries in the world by the United Nations and World Bank and are widely used to study the cumulative effects of international migration.\n\n\n2.1.3 Migrant Transition Data\nMigrant transition data are a key element of migration analysis and estimation and are typically collected in national censuses, which identify migrants by comparing their place of usual residence at the time of enumeration (\\(t\\)) with that at a specified earlier date (\\(t-n\\)). This type of data provides information on the movements of migrants over a given time period, which is usually either 1 year (e.g. UK) or 5 years (e.g. USA). In terms of limitations, as mentioned above, migrant transition data fail to identify multiple and return moves, which can lead to an underestimation of the true level of migration. Additionally, migrants who are born or who die during the measurement period are not counted. For example, a baby born three years ago would not have a place of usual residence five years ago. Surveys may also be used to gather migration data but the sample size must be sufficient to capture what is usually a small proportion of the population making a residential transition. In any given year, the vast majority of the population do not migrate domestically, let alone internationally.\nIn migrant transition data, a migrant is a person who has experienced one or more migrations during a period measured retrospectively. It is important to note that persons who moved during the measurement interval and subsequently died before its end should technically be counted as migrants and their moves as migrations. However, in practice, such cases are usually unknown or excluded, as the information is usually obtained at the end of the time interval and with reference to persons who are alive at that time. Similarly, with international migration, censuses can be used to measure immigrant transitions but not emigrant transitions. The reason is that the current place of residence is in country not gathering the census data. Censuses and surveys have been used to ask questions about family members who have emigrated but if the whole family migrated, then again, censuses would not capture them.This so-called network or multiplicity approach to measuring individual and household migration and emigration is an area of ongoing exploration by migration researchers.\n\n\n2.1.4 Migation Event Data\nMigration event data record all moves made by individuals included in an administrative system or a population register. Depending on the purpose and characteristics of the registration system, data are available for multiple and return moves, as well newborn moves, and moves immediately before death, and moves among households, for example, for marriage. Ideally, moves come from a centralised population register, however, other registers that do not necessarily cover the whole population may be used for migration analysis. For instance, some countries require persons to register with local health clinics when moves are made, others may use tax file reports with updated address information as sources of moves. Other administrative registers address enrollment in schools and or voting registrations. As we consider below, it is important to appreciate the critical relationship between migration event data and the total resident population for the analysis of patterns and use in demographic measurement and estimation models.\nWhile registers tend to provide a more complete record of migration over time, they may not be inclusive of the whole population, for example, military personnel and prisoners may not be included in registers of the national ‘noninstitutional’ population. .There may be instances where people do not register initially or fail to de-register with departing or changing status. For example, a common problem with health registration data is young adults (especially males) only register when they see a doctor (which may be several years after the move) or they do not register in their new place of residence, but continue to visit the health clinic serving their parental home. . Another issue is that geographical units adopted in administrative registers are generally larger, often regional, , and registers often fail to capture within-region moves. Additionally, administrative registers often do not include information about the characteristics of migrants outside age and sex."
  },
  {
    "objectID": "01-concepts.html#temporal",
    "href": "01-concepts.html#temporal",
    "title": "2  Migration Concepts",
    "section": "2.2 Temporal",
    "text": "2.2 Temporal\n\n2.2.1 Migration Interval\nAt the population level, migration is a continuous process that occurs over time. To study the propensity or rate of migration, data must be compiled with reference to specific periods of time. These time periods can be either definite or indefinite. Definite interval data are typically collected over fixed-term periods such as one year, five years, ten years, or, in the context of national census-taking, intercensal periods. Indefinite interval data such as lifetime migration measures or data based on place of last residence lack a definite time reference as age or time at the current residence varies by each individual migrant.\nThe comparability of migration data with different definite time intervals can be prohibitively complicated. Commonly described as the ‘one-year / five-year problem,’ observed migration data consistently show that the number of migrants recorded over a five-year interval is far less than five times the number recorded over a one-year interval. In addition, the ratio of migrants between a five-year period and a one-year period is not constant, where variations occur depending on multiple factors such as the intensity and type of migration both over time and in each place of origin and destination. Consequently, there is no straightforward algebraic (mathematical?) solution to comparing one-year and five-year migration probabilities (Rogerson1990?).\nIssues of temporality in migration data are particularly challenging for international comparison. Countries measure international migration (immigration and emigration) for their own national policy and administrative purposes, often embedded registers and data systems. The result is great variation among national practices in international migration statistics. While the United Nations recommends measures that are aligned with changes in the country of usual residence, the reality is that countries may differ greatly, ranging from, say, no defined time period, three months, six months, or 12 months. Some countries with more effective border control practices to track all entries and exits are able to generate statistics with great temporal detail and acccuracy. In Australia, for example, an immigrant is someone who was previously living abroad and stays in the country for 12/16 months. Similarly, an emigrant is someone who has been outside Australia for 12/16 months. In contrast, some countries, especially in Eastern Europe, have population registers that rely on the notion of a ‘permanent’ residence, implying that persons leaving (entering) will never return (leave). Reliance on the concept of ‘permanent residence’ results in gross undercounts of the true levels of migration. (Cite MIMOSA / IMEM papers)"
  },
  {
    "objectID": "01-concepts.html#migration-measures",
    "href": "01-concepts.html#migration-measures",
    "title": "2  Migration Concepts",
    "section": "2.3 Migration Measures",
    "text": "2.3 Migration Measures\nMigration measures are used to quantify the magnitude, direction and pace of population movements between places at different geographic scales. . These measures provide important insights into the demographic and social characteristics and dynamics of populations. There are several different types of migration measures that are commonly used in both research and policy analysis and evaluation. ach measure embodies its own analytic strengths and limitations; each should be used in relationship to the general and specific goals of the research project or policy analysis.\nOne of the most common migration measures is the migration rate or migration intensity. A migration rate or intensity is defined as the number of migrants observed during a period of time divided by the mid-year population (or average population ‘at risk’ of migration). The migration rate can be calculated for different migration types discussed above, such as one year or five years, and maintaining the same measure, can be used to compare migration across different places or regions. It is important to note that the probability of migration is different from a rate in just how the ‘at risk’ population is defined. In a rate, the population at risk is the mid-year (average) population, whereas in probability, the population at the beginning of the time interval is used as the population at risk.\nOther migration measures derive from the perspective of population and migration stock discussed above. Using stock data, the count of the number of migrants is the basis for measuringthe migrant proportion. The migrant proportion is the share of the population that has migrated, measured at one point in time, for example, x% of the national population born outside of the country (using lifetime migration data). These measures can be useful for identifying patterns in migration behavior, such as the prevalence of long-distance migration or the likelihood of migration among certain social demographic groups – males and females, working ages and youth. In demography, denominators of measures are critical. For example, some analysts would argue that in the study of international migration there is no such thing as a in-migration or immigration rate since the ’population at risk consists of (all!) national populations beyond the country of interest. Rather these measures of immigration are simply ratios that compare the number of migrants to the size of the receiving population. This problem does not exist for out-migration rates or emigration rates since both have clear populations at risk of onward migration.\nAs you are no doubt aware, all migration measures are affected by data quality, such as underreporting of migrants (reliability issues) or errors in place of residence information (validity issues)These problems tend to increase as the data become more detailed in terms of intricacies in definitions of migrants and migration.\nAdditionally, different measures may be more appropriate for different research questions or policy applications. For example, the migration rate may be more useful for understanding the overall magnitude of migration in the population, while the count of migrants can provide a basic understanding of the scale of migration patterns over time and between different spatial units with implications for programs supporting the needs of migrants in specific places\nMigration measures can be defined at different levels of detail, ranging from region-to-region measures, to region totals, to system totals or index measures. Region-to-region measures capture the flow of migrants between two specific regions, while region totals capture the total number of migrants coming in or going out of a specific region. System totals, or index measures, provide an overall picture of migration within a given system or country, which we will discuss in more detail in the next chapter.\n\n2.3.1 Region-to-region\nWe now move this discussion of migration measures and indices to consider region-to-region migration using measures represented by R notation.\nRegion-to-region migration, also known as bilateral migration, migration streams or origin-destination migration, refers to a migration measure that cross-classifies region of origin by region of destination, forming a matrix of \\(n \\times (n-1)\\) streams along each origin-destination combination, where \\(n\\) represents the number of regions. The set of region-to-region migration measures can be represented by \\(m_{ij}\\), where the sub-scripts \\(i\\) and \\(j\\) represent the same set of regions for each origin-destination combination. The set of bilateral migration flows provide a basis to assess the comparative volumes and directions of migration between a set of regions.\nThe gross interchange represents the total number of migrants moving between a particular pair of regions, for example, \\(m_{ij} + m_{ji}\\). The net migration steam or bilateral net migration represents the difference in migration between a pair of region i.e. \\(m_{ij} - m_{ji}\\).\nFor a pair of streams that are of unequal size, where the net migration stream is not close to zero, there exists a dominant stream which is far larger than the reverse or counter stream in the opposite direction.\n\n\n2.3.2 Region Totals\nEvery migration event can be considered an out-migration in relation to the region of origin and an in-migration in relation to the region of destination. As implicitly covered above, when migration events involve movement between countries , migration events are typically described as emigration and immigration, rather than out-migration and in-migration.\nTotals on in- or out-migration for each region are typically used to evaluate the volume of migration to or from a particular set of regions. In some countries, data is collected or aggregated without reference to the place of origin for in-migration totals or destination for out-migration totals. Consequently the migration totals provide the most detailed measure of regional migration but with little information on the direction of the migration flows between each region. A summary of the common terms for migration totals are shown in Table 1. The in-migration (or immigration) totals can be represented by replacing the origin \\(i\\) index with a \\(+\\); \\(m_{+j}\\). Similarly, the out-migration (or emigration) totals can be represented by replacing the destination \\(j\\) index with \\(+\\); \\(m_{+j}\\).\nFor our purposes in using R for migration analysis in the next several chapters and exercises, migration totals will refer to in-migration and out-migration, but are consistent with immigration and emigration, respectively.\n\n\n\nScale\nArea\nEvent Term\nMigrant Term\n\n\n\n\nInternal\nOrigin\nout-migration\nout-migrant\n\n\n\nDestination\nin-migration\nin-migrant\n\n\nInternational\nOrigin\nemigration\nemigrant\n\n\n\nDestination\nimmigration\nimmigrant\n\n\n\nThe sum of the in-migration and out-migration totals (\\(m_{i+} + m_{+j}\\)) provides the migration turnover of each region. Net migration totals provides a balance of movements in opposing directions from the difference between in-migration and out-migration (\\(m_{+j} - m_{i+}\\)). Net migration measures are more typically obtained via demographic accounting, as a residual from the differences in population change, births and deaths over a period in each region. As this calculation does not require expensive migration data collection systems, net migration measures are one of the most common forms of migration measures.\nNet migration measures, however, have a number of notable drawbacks for migration analysis, as highlighted by (rogers1990rnm?). In particular, net migration does not enumerate migrants themselves, but instead follows a residual of in-migrants and out-migrants. (there is truly no such thing as a ‘net migrant’!) Consequently, the social and behavioral dynamics related to the observed migration patterns can be missed. For example, a net migration of -100 might involve a region receiving no in-migrants and sending 100 out-migrants or receiving 1,000,000 migrants and sending 1,000,100 out-migrants. Further migration dynamics are also missed when looking at net migration rates (discussed in the next section) and regularities in age profiles of migration (discussed in Chapter X) are often preceded when using age-specific net migration measures.\n\n\n2.3.3 Rate measures\nMigration rates are important indicators for understanding the dynamic nature of population movements - over time and for comparison among places. Out-migration (or emigration) rates are calculated by dividing the number of out-migrants or emigrants during a specific period by the population exposed to the likelihood of migration. This is represented by the formula:\n\\[\ne^{[t, t +1]} = \\frac{E^{[t, t +1]}}{P}k\n\\]\nHere, \\(e^{[t, t+1]}\\) represents the out or emigration rate, \\(E^{[t, t +1]}\\) is the number of out-migrants or emigrants during the period, \\(P\\) is the population exposed to the likelihood of migration, and \\(k\\) is a constant, often set as 1000. The exposure population can be the population at the mid-interval, assuming migration is evenly distributed, or the population at the start or end of the interval if migration has a negligible effect on population change. Additionally, out-migration rates can be further decomposed by subsets of the population, such as age or sex:\n\\[\ne^{[t, t +1]}_{i} = \\frac{E_{i}^{[t, t +1]}}{P_{i}}k\n\\]\nOn the other hand, in-migration (or immigration) ratios are calculated by dividing the number of in-migrants or immigrants by the population not exposed to the risk of migrating into the region. The formula for in-migration ratio is:\n\\[\ni^{[t, t +1]} = \\frac{I^{[t, t +1]}}{P}k\n\\]\nSimilarly, net migration ratios are calculated by dividing the net migration (difference between in-migration and out-migration) by the population not exposed to migration risk:\n\\[\nm^{[t, t +1]} = \\frac{M^{[t, t +1]}}{P}k\n\\]\nTo underscore our previous point, , in-migration and net migration ratios are different from demographic rates because they use the resident population in the denominator, which is not a valid ‘population at risk.’. This approach satisfies the needs of the demographic balancing equation, as rates of gain and loss are measured relative to the same population. The demographic balancing equation is expressed as:\n\\[\n\\begin{aligned}\nP^{t+1} &=  P^{t} + B^{[t, t +1]} - D^{[t, t +1]} +  M^{[t, t +1]} \\\\\nP^{t+1} &=  P^{t} \\left(1 + b^{[t, t +1]} - d^{[t, t +1]} +  m^{[t, t +1]} \\right)\\\\\n&= P^{t} \\left(1 + b^{[t, t +1]} - d^{[t, t +1]} +  i^{[t, t +1]} - e^{[t, t +1]} \\right)\n\\end{aligned}\n\\]\nwhere \\(P^{t+1}\\) is the population at the next time point, \\(b^{[t, t+1]}\\) and \\(d^{[t, t+1]}\\) represent births and deaths during the period, and $i^{[t, t+1]} $ and \\(e^{[t, t+1]}\\) denote in-migration and out-migration rates. Net migration \\(M^{[t, t+1]}\\) can be substituted with the difference between in-migration and out-migration \\(I^{[t, t+1]} - O^{[t, t+1]}\\). The equation can be simplified as:\n\\[\n\\begin{aligned}\nP^{t+1}&= P^{t} + B^{[t, t +1]} - D^{[t, t +1]} +  I^{[t, t +1]} - O^{[t, t +1]} \\\\\n&= P^{t} \\left(1 + b^{[t, t +1]} - d^{[t, t +1]} +  i^{[t, t +1]} - o^{[t, t +1]} \\right)\n\\end{aligned}\n\\]\nThis formulation allows for the analysis of population change considering the effects of births, deaths, in-migration, and out-migration."
  },
  {
    "objectID": "02-data.html#contingency-table",
    "href": "02-data.html#contingency-table",
    "title": "\n3  Handling Migration Data in R\n",
    "section": "\n3.1 Contingency Table",
    "text": "3.1 Contingency Table\nBilateral migration data are often organized and represented in square tables, commonly referred to as migration matrices or migration flow tables. These tables are contingency tables, otherwise know as cross-tabulations or frequency tables, used in data analysis and statistics. Migration flow tables provide a structured way to organize and summarize origin-destination migration data, with rows representing the regions of origin and columns representing the regions of destinations. The cells in the table capture the number of persons migrating from one region to another. The inspection of migration tables themselves provide valuable insights into the magnitudes and directions of migration between different regions.\n\n\n\n\nOrigin\n\n\nDestination\n\n\n\n\n\n\nA\n\n\nB\n\n\nC\n\n\nD\n\n\nSum\n\n\n\n\nA\n\n\n\n\n100\n\n\n30\n\n\n70\n\n\n200\n\n\n\n\nB\n\n\n50\n\n\n\n\n45\n\n\n5\n\n\n100\n\n\n\n\nC\n\n\n60\n\n\n35\n\n\n\n\n40\n\n\n135\n\n\n\n\nD\n\n\n20\n\n\n25\n\n\n20\n\n\n\n\n65\n\n\n\n\nSum\n\n\n130\n\n\n160\n\n\n95\n\n\n115\n\n\n500\n\n\n\nThe diagonal cells in migration flow tables represent populations that either do not migrate (remain) or make moves within the same region. These values are useful to provide a relative sense of migration in relation to local mobility or to the population not migrating. Alternatively, one can place zeros in the diagonal elements (or nothing as in the table above) so that the table only consists of those migrating between regions."
  },
  {
    "objectID": "02-data.html#data-creation",
    "href": "02-data.html#data-creation",
    "title": "\n3  Handling Migration Data in R\n",
    "section": "\n3.2 Data Creation",
    "text": "3.2 Data Creation\nIn R, migration flow tables can be created directly using the matrix() or array() functions. Both functions create array type objects. They are sometimes a pre-requisite for more complicated functions used for describing, estimating or visualising bilateral migration data.\nThe matrix() function allows users to specify the dimensions of the matrix and populate it with desired values. It can be used to create matrices of any size, and supports various options for filling in the matrix, such as using a sequence of numbers, replicating values, or using auxiliary data sources. Data is provided via a vector passed to the data argument. By default the data populates the matrix from the first column on, which can be altered by setting byrow = FALSE.\n\nm0 <- matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0),\n             nrow = 4, ncol = 4, byrow = TRUE)\nm0\n\n     [,1] [,2] [,3] [,4]\n[1,]    0  100   30   70\n[2,]   50    0   45    5\n[3,]   60   35    0   40\n[4,]   20   25   20    0\n\n\nIt is often valuable to supply a vector of character strings for the origin and destination names to the matrix data object. These can be linked to an existing matrix object using the dimnames() via the dimnames argument. The corresponding rownames() and colnames() functions can be used to assign or display individual dimension names.\n\n# create region labels\nr <- LETTERS[1:4]\nr\n\n[1] \"A\" \"B\" \"C\" \"D\"\n\n# check dimension names\ndimnames(m0)\n\nNULL\n\n# add dimension names\ndimnames(m0) <- list(orig = r, dest = r)\nm0\n\n    dest\norig  A   B  C  D\n   A  0 100 30 70\n   B 50   0 45  5\n   C 60  35  0 40\n   D 20  25 20  0\n\n# create matrix with dimension names directly\n# m0 <- matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0),\n#              nrow = 4, ncol = 4, byrow = TRUE,\n#              dimnames = list(orig = r, dest = r))\n\nIn R, the array() function is used to create multidimensional arrays, which can have more than two dimensions. While the matrix() function creates two-dimensional structures.\nSimilar to the matrix() function, the array() function allows users to define the dimensions of the array and populate it with desired values. However, in the array() function, the dimensions are specified as a vector to the dim argument, indicating the size of each dimension. The array() function can be seen as a generalization of the matrix() function, as matrices are a specific type of two-dimensional arrays. By using the array() function, users can work with data that requires more complex organization and analysis, such as migration flows cross classified by origin, destination and additional variables such as sex, age or education.\n\nm1 <- array(data = sample(x = 1:100, size = 32),\n            dim = c(4, 4, 2),\n            dimnames = list(orig = r, dest = r, sex = c(\"female\", \"male\")))\nm1\n\n, , sex = female\n\n    dest\norig  A  B  C  D\n   A 31 89 22 56\n   B 55 28 40 25\n   C  6 74 83 16\n   D 48 49 62 29\n\n, , sex = male\n\n    dest\norig   A  B  C  D\n   A  84 43  3 42\n   B  46 52 65 17\n   C 100 71  7 23\n   D  34 70 67 77"
  },
  {
    "objectID": "02-data.html#data-manipulation",
    "href": "02-data.html#data-manipulation",
    "title": "\n3  Handling Migration Data in R\n",
    "section": "\n3.3 Data Manipulation",
    "text": "3.3 Data Manipulation\nStatistical offices, government agencies, and international organizations collect and disseminate migration data in different formats to accommodate the needs of users and researchers. The format of the data may not necessarily be in square matrices that can be read directly into R and converted into a matrix object. However, there are useful functions in R that can be employed to convert data into appropriate formats for migration analysis.\nThe xtabs() function is particularly helpful as it enables the conversion of data frames in a tidy format (Wickham2014?) into matrices or arrays. It requires a formula argument that specifies the column names in the data frame that will be used to construct and populate the matrix or array. The formula consists of the left-hand side representing the column name with the data to fill, the ~ symbol to separate the left and right-hand sides, and the right-hand side representing the columns used for cross-classifying the left-hand variable (separated by +). The data argument specifies the object where the data presented in a tidy format with variables included in the formula.\n\n\n# A tibble: 16 × 3\n   orig  dest   flow\n   <chr> <chr> <int>\n 1 A     A         1\n 2 A     B         2\n 3 A     C         3\n 4 A     D         4\n 5 B     A         5\n 6 B     B         6\n 7 B     C         7\n 8 B     D         8\n 9 C     A         9\n10 C     B        10\n11 C     C        11\n12 C     D        12\n13 D     A        13\n14 D     B        14\n15 D     C        15\n16 D     D        16\n\n\n    dest\norig  A  B  C  D\n   A  1  2  3  4\n   B  5  6  7  8\n   C  9 10 11 12\n   D 13 14 15 16\n\n\nThe as.data.frame.table() function provides an inverse of the data manipulation of the xtabs() function, whereby it takes a matrix or array and converts it into a data frame based on the array dimension names. The responseName argument can be used to set the column name of the values in the cells of the matrix or array.\n\n# convert previous matrix back to tibble\nm2 %>%\n  as.data.frame.table(responseName = \"migration\") %>%\n  as_tibble()\n\n# A tibble: 16 × 3\n   orig  dest  migration\n   <fct> <fct>     <int>\n 1 A     A             1\n 2 B     A             5\n 3 C     A             9\n 4 D     A            13\n 5 A     B             2\n 6 B     B             6\n 7 C     B            10\n 8 D     B            14\n 9 A     C             3\n10 B     C             7\n11 C     C            11\n12 D     C            15\n13 A     D             4\n14 B     D             8\n15 C     D            12\n16 D     D            16\n\n\nNote, above we use as_tibble() to convert the data.frame object returned from as.data.frame.table() to the more user friendly tibble object type (insert citation) and use the pipe line function %>% to combine together a sequence of R functions.\n\n# convert array to tibble\nd1 <- m1 %>%\n  as.data.frame.table(responseName = \"flow\") %>%\n  as_tibble()\nd1\n\n# A tibble: 32 × 4\n   orig  dest  sex     flow\n   <fct> <fct> <fct>  <int>\n 1 A     A     female    31\n 2 B     A     female    55\n 3 C     A     female     6\n 4 D     A     female    48\n 5 A     B     female    89\n 6 B     B     female    28\n 7 C     B     female    74\n 8 D     B     female    49\n 9 A     C     female    22\n10 B     C     female    40\n# … with 22 more rows"
  },
  {
    "objectID": "02-data.html#matrix-operations",
    "href": "02-data.html#matrix-operations",
    "title": "\n3  Handling Migration Data in R\n",
    "section": "\n3.4 Matrix Operations",
    "text": "3.4 Matrix Operations\nWhen working with matrix objects based on migration data in R there are additional functions that are useful for further formatting and data exploration. The addmargins() function is a useful tool for adding row and column margin totals to a matrix or array object.\n\naddmargins(A = m0)\n\n     dest\norig    A   B  C   D Sum\n  A     0 100 30  70 200\n  B    50   0 45   5 100\n  C    60  35  0  40 135\n  D    20  25 20   0  65\n  Sum 130 160 95 115 500\n\n\nWhen working with migration matrices in R, it can sometimes be challenging to effectively view and analyze the data due to various factors such as lengthy dimension names and large unit sizes. Additionally, the inclusion of diagonal terms, which are often not of interest in migration analysis, can further complicate the interpretation of the matrix. R provides several helpful functions that can assist in adapting migration matrix objects for easier viewing and analysis. To illustrate, we use the uar_1960 object from the migest package, which represents a lifetime migration matrix for the Governorates of the United Arab Republic in 1960 as documented in the United Nations manual by (UnitedNations1983?). Notice how the object is difficult to view due to issues described above:\n\nlibrary(migest)\nuar_1960\n\n            dest\norig           Cairo Alexandria Port-Said Ismailia Kalyubia Gharbia Menoufia\n  Cairo      2079434      31049      5293     9813    23837   10034     7038\n  Alexandria   47220    1085602      2641     2625     2135    4921     1505\n  Port-Said     9464       2562    168046     6461      496     817      323\n  Ismailia      9518       1395      3490   171297      718     910      306\n  Kalyubia     90668       4730       758     3182   886464    3727     3523\n  Gharbia      99179      39953      1742     3347     7870 1604851     6313\n  Menoufia    216764      46781      1640     3338     2918   29580  1308283\n  Giza         64584       4899       513     2013     2887    1503     2161\n  Assyiut     100305      25497      1738     2522      122    2245      636\n  Souhag      100100      63712     12087     9436      295    2791     1095\n  All others  456464     177476     43898    66973    49816   47315    12179\n            dest\norig            Giza Assyiut  Souhag All others\n  Cairo        88543    4951    2569      58476\n  Alexandria    6910    1355    1467      29534\n  Port-Said     1505     326     454      11184\n  Ismailia      1593     319     263      10269\n  Kalyubia     10279     340     128      18076\n  Gharbia      14529     848     491      64140\n  Menoufia     30915     567     401      47843\n  Giza       1040179     540     433      13518\n  Assyiut      13153 1290255    5955      35157\n  Souhag       17958   11608 1540020      53224\n  All others   94577   14690   22375   11900302\n\n\nWhen working with names or labels that are lengthy or contain unnecessary details, the abbreviate() function can be helpful. The function applies an algorithm to shorten the names while still retaining their essential information.\n\ndimnames(uar_1960)\n\n$orig\n [1] \"Cairo\"      \"Alexandria\" \"Port-Said\"  \"Ismailia\"   \"Kalyubia\"  \n [6] \"Gharbia\"    \"Menoufia\"   \"Giza\"       \"Assyiut\"    \"Souhag\"    \n[11] \"All others\"\n\n$dest\n [1] \"Cairo\"      \"Alexandria\" \"Port-Said\"  \"Ismailia\"   \"Kalyubia\"  \n [6] \"Gharbia\"    \"Menoufia\"   \"Giza\"       \"Assyiut\"    \"Souhag\"    \n[11] \"All others\"\n\n# make a copy\nu0 <- uar_1960\n# new abbreviated region names\nr <- list(orig = uar_1960 %>%\n            rownames() %>%\n            abbreviate(),\n          dest = uar_1960 %>%\n            colnames() %>%\n            abbreviate())\nr\n\n$orig\n     Cairo Alexandria  Port-Said   Ismailia   Kalyubia    Gharbia   Menoufia \n    \"Cair\"     \"Alxn\"     \"Pr-S\"     \"Isml\"     \"Klyb\"     \"Ghrb\"     \"Menf\" \n      Giza    Assyiut     Souhag All others \n    \"Giza\"     \"Assy\"     \"Sohg\"     \"Allo\" \n\n$dest\n     Cairo Alexandria  Port-Said   Ismailia   Kalyubia    Gharbia   Menoufia \n    \"Cair\"     \"Alxn\"     \"Pr-S\"     \"Isml\"     \"Klyb\"     \"Ghrb\"     \"Menf\" \n      Giza    Assyiut     Souhag All others \n    \"Giza\"     \"Assy\"     \"Sohg\"     \"Allo\" \n\n# apply the abbreviated region names\ndimnames(u0) <- r\n\nu0\n\n      dest\norig      Cair    Alxn   Pr-S   Isml   Klyb    Ghrb    Menf    Giza    Assy\n  Cair 2079434   31049   5293   9813  23837   10034    7038   88543    4951\n  Alxn   47220 1085602   2641   2625   2135    4921    1505    6910    1355\n  Pr-S    9464    2562 168046   6461    496     817     323    1505     326\n  Isml    9518    1395   3490 171297    718     910     306    1593     319\n  Klyb   90668    4730    758   3182 886464    3727    3523   10279     340\n  Ghrb   99179   39953   1742   3347   7870 1604851    6313   14529     848\n  Menf  216764   46781   1640   3338   2918   29580 1308283   30915     567\n  Giza   64584    4899    513   2013   2887    1503    2161 1040179     540\n  Assy  100305   25497   1738   2522    122    2245     636   13153 1290255\n  Sohg  100100   63712  12087   9436    295    2791    1095   17958   11608\n  Allo  456464  177476  43898  66973  49816   47315   12179   94577   14690\n      dest\norig      Sohg     Allo\n  Cair    2569    58476\n  Alxn    1467    29534\n  Pr-S     454    11184\n  Isml     263    10269\n  Klyb     128    18076\n  Ghrb     491    64140\n  Menf     401    47843\n  Giza     433    13518\n  Assy    5955    35157\n  Sohg 1540020    53224\n  Allo   22375 11900302\n\n\nBasic arithmetic operators can be employed to scale the data to an appropriate level, such as dividing the values by a common factor or multiplying them to achieve a desired magnitude. This can be useful when working with migration matrices to adjust the values and make them more interpretable or comparable. The round() function which allows users to specify the precision of numbers in your migration data, which can be handy when working with migration rates or proportions.\n\nu1 <- round(x = u0/1000, digits = 1)\nu1\n\n      dest\norig     Cair   Alxn  Pr-S  Isml  Klyb   Ghrb   Menf   Giza   Assy   Sohg\n  Cair 2079.4   31.0   5.3   9.8  23.8   10.0    7.0   88.5    5.0    2.6\n  Alxn   47.2 1085.6   2.6   2.6   2.1    4.9    1.5    6.9    1.4    1.5\n  Pr-S    9.5    2.6 168.0   6.5   0.5    0.8    0.3    1.5    0.3    0.5\n  Isml    9.5    1.4   3.5 171.3   0.7    0.9    0.3    1.6    0.3    0.3\n  Klyb   90.7    4.7   0.8   3.2 886.5    3.7    3.5   10.3    0.3    0.1\n  Ghrb   99.2   40.0   1.7   3.3   7.9 1604.9    6.3   14.5    0.8    0.5\n  Menf  216.8   46.8   1.6   3.3   2.9   29.6 1308.3   30.9    0.6    0.4\n  Giza   64.6    4.9   0.5   2.0   2.9    1.5    2.2 1040.2    0.5    0.4\n  Assy  100.3   25.5   1.7   2.5   0.1    2.2    0.6   13.2 1290.3    6.0\n  Sohg  100.1   63.7  12.1   9.4   0.3    2.8    1.1   18.0   11.6 1540.0\n  Allo  456.5  177.5  43.9  67.0  49.8   47.3   12.2   94.6   14.7   22.4\n      dest\norig      Allo\n  Cair    58.5\n  Alxn    29.5\n  Pr-S    11.2\n  Isml    10.3\n  Klyb    18.1\n  Ghrb    64.1\n  Menf    47.8\n  Giza    13.5\n  Assy    35.2\n  Sohg    53.2\n  Allo 11900.3\n\n\nThe diag() function allows users to manipulate the diagonal terms of a matrix, which can be much larger than the number of persons migrating in the non-diagonal cells. The diag() function takes a matrix as input and returns a new matrix with the same values, except that the diagonal elements are modified according to the specified rule. In the context of migration data, setting the diagonal terms to zero effectively removes the non-moving populations from the matrix, making it easier to analyze the migration flows.\n\nu2 <- u0\ndiag(u2) <- 0\nu2\n\n      dest\norig     Cair   Alxn  Pr-S  Isml  Klyb  Ghrb  Menf  Giza  Assy  Sohg  Allo\n  Cair      0  31049  5293  9813 23837 10034  7038 88543  4951  2569 58476\n  Alxn  47220      0  2641  2625  2135  4921  1505  6910  1355  1467 29534\n  Pr-S   9464   2562     0  6461   496   817   323  1505   326   454 11184\n  Isml   9518   1395  3490     0   718   910   306  1593   319   263 10269\n  Klyb  90668   4730   758  3182     0  3727  3523 10279   340   128 18076\n  Ghrb  99179  39953  1742  3347  7870     0  6313 14529   848   491 64140\n  Menf 216764  46781  1640  3338  2918 29580     0 30915   567   401 47843\n  Giza  64584   4899   513  2013  2887  1503  2161     0   540   433 13518\n  Assy 100305  25497  1738  2522   122  2245   636 13153     0  5955 35157\n  Sohg 100100  63712 12087  9436   295  2791  1095 17958 11608     0 53224\n  Allo 456464 177476 43898 66973 49816 47315 12179 94577 14690 22375     0"
  },
  {
    "objectID": "02-data.html#summaries",
    "href": "02-data.html#summaries",
    "title": "\n3  Handling Migration Data in R\n",
    "section": "\n3.5 Summaries",
    "text": "3.5 Summaries\n\n3.5.1 Bilateral measures\nthe migest package offers several useful functions for generating summaries of origin-destination migration data. One such function is sum_bilat(), which allows you to calculate the counter flow, net flow and interchange for all migration pairs. This function can accept either a matrix, array or a data.frame (or tibble) as input.\n\nsum_bilat(m0)\n\n# A tibble: 12 × 8\n   orig  dest  corridor pair   flow counter_flow net_flow interchange\n   <chr> <chr> <chr>    <chr> <dbl>        <dbl>    <dbl>       <dbl>\n 1 B     A     B -> A   A - B    50          100      -50         150\n 2 C     A     C -> A   A - C    60           30       30          90\n 3 D     A     D -> A   A - D    20           70      -50          90\n 4 A     B     A -> B   A - B   100           50       50         150\n 5 C     B     C -> B   B - C    35           45      -10          80\n 6 D     B     D -> B   B - D    25            5       20          30\n 7 A     C     A -> C   A - C    30           60      -30          90\n 8 B     C     B -> C   B - C    45           35       10          80\n 9 D     C     D -> C   C - D    20           40      -20          60\n10 A     D     A -> D   A - D    70           20       50          90\n11 B     D     B -> D   B - D     5           25      -20          30\n12 C     D     C -> D   C - D    40           20       20          60\n\n\n\n3.5.2 Total Measures\nAnother useful function in the migest package is sum_region(), which allows you to generate comprehensive summaries of in-migration, out-migration, net migration, and turnover totals for each region in your migration data. Similar to the sum_bilat() function, sum_region() also accepts either a matrix or a data.frame (or tibble) as input, providing flexibility in working with different data formats.\nBy using the sum_region() function, you can obtain valuable information about migration flows at the regional level. It calculates the total number of migrants moving into each region (in-migration), the total number of migrants moving out of each region (out-migration), the net migration balance (in-migration minus out-migration), and the turnover (sum of in-migration and out-migration) for each region. These summaries are useful for further analyses and interpretations.\n\nsum_region(m0)\n\n# A tibble: 4 × 5\n  region out_mig in_mig  turn   net\n  <chr>    <dbl>  <dbl> <dbl> <dbl>\n1 A          200    130   330   -70\n2 B          100    160   260    60\n3 C          135     95   230   -40\n4 D           65    115   180    50\n\n\nNote, when the data provided to the sum_region() is a data frame, the origin and destination regions names are assumed to be in variables named orig and dest. In addition, the migration data are assumed to be in variable named flow. If the corresponding column names differ, the user can supply these to the orig_col, dest_col and flow_col argumenets in the sum_region() function.\nThe sum_country() function provides the same calculations, along with summary variables names. When the input data for either the sum_region() or sum_country() functions represent more than two dimensions, the group_by function from the dplyr package should be used. To demonstrate, we use the international flow estimates of (Abel2019?) which can be downloaded and read directly into R from the online CSV file.\n\n# read data from web depository\nf <- read_csv(\"https://ndownloader.figshare.com/files/26239945\")\nf\n\n# A tibble: 235,236 × 9\n   year0 orig  dest  sd_drop_neg sd_rev_neg mig_rate da_min_open da_mi…¹ da_pb…²\n   <dbl> <chr> <chr>       <dbl>      <dbl>    <dbl>       <dbl>   <dbl>   <dbl>\n 1  1990 BDI   BDI             0          0        0           0       0       0\n 2  1990 COM   BDI             0          0        0           0       0       0\n 3  1990 DJI   BDI             0          0        0           0       0       0\n 4  1990 ERI   BDI             0          0        0           0       0      90\n 5  1990 ETH   BDI             0          0        0           0       0       2\n 6  1990 KEN   BDI            30         30       69          45      29      87\n 7  1990 MDG   BDI             0          0        0           0       0       0\n 8  1990 MWI   BDI             0          0        0           0       0     125\n 9  1990 MUS   BDI             0          0        0           0       1       1\n10  1990 MYT   BDI             0          0        0           0       0       0\n# … with 235,226 more rows, and abbreviated variable names ¹​da_min_closed,\n#   ²​da_pb_closed\n\n# single period (1990-1995)\nf %>%\n  filter(year0 == 1990) %>%\n  sum_country(flow_col = \"da_pb_closed\")\n\n# A tibble: 197 × 5\n   country    emi     imm    turn     net\n   <chr>    <dbl>   <dbl>   <dbl>   <dbl>\n 1 ABW       1662   15874   17536   14212\n 2 AFG     345255 3421712 3766967 3076457\n 3 AGO      82775  225637  308412  142862\n 4 ALB     464693   21479  486172 -443214\n 5 ARE     272648  640784  913432  368136\n 6 ARG     444239  339393  783632 -104846\n 7 ARM     648202  151937  800139 -496265\n 8 ATG       6153    8387   14540    2234\n 9 AUS     691618 1042781 1734399  351163\n10 AUT     154853  382724  537577  227871\n# … with 187 more rows\n\n# all periods using group_by\nf %>%\n  group_by(year0) %>%\n  sum_country(flow_col = \"da_pb_closed\") %>%\n  arrange(country)\n\n# A tibble: 1,188 × 6\n# Groups:   year0 [6]\n   year0 country     emi     imm    turn      net\n   <dbl> <chr>     <dbl>   <dbl>   <dbl>    <dbl>\n 1  1990 ABW        1662   15874   17536    14212\n 2  1995 ABW        4007   10945   14952     6938\n 3  2000 ABW        3814   10064   13878     6250\n 4  2005 ABW        7544    7124   14668     -420\n 5  2010 ABW        8654    9910   18564     1256\n 6  2015 ABW       16306   17316   33622     1010\n 7  1990 AFG      345255 3421712 3766967  3076457\n 8  1995 AFG     1286436  418906 1705342  -867530\n 9  2000 AFG      434706 1178865 1613571   744159\n10  2005 AFG     1500149  457339 1957488 -1042810\n# … with 1,178 more rows"
  },
  {
    "objectID": "04-indices.html#migration-intensity",
    "href": "04-indices.html#migration-intensity",
    "title": "\n5  Summary Migration Indices\n",
    "section": "\n5.1 Migration intensity",
    "text": "5.1 Migration intensity\nMigration intensity measures focus on capturing the overall level or incidence (rate or propensity) of migration. These measures aim to provide a single indicator that allows for comparisons of migration levels over time, across regions for for the system as a whole. They are very useful in helping researchers understand the relative magnitude of migration when making camparisons. In our examples, we focus on the aggregate totals of migration. Indicators for examining age-specific patterns of migration are presented in the next chapter.\nCrude migration intensity (CMP) is a straightforward measure that provides an indication of the overall propensity to migrate. They are analogous to crude birth or death rates. The basic requirement for this indicator is a total number of persons changing their places of residence within a regional system. The system can include only migrants, i.e., only those cross geographic boundaries (or zeros in the diagonal of a migration flow table), or all persons changing residence (including within region moves). The CMP is calculated by dividing the total number of migrants (or movers) (\\(M\\)) during a specific time period by the mid-period population at risk (\\(P\\)), multiplied by 100 to express it as a percentage.\\[\n\\texttt{CMP} = 100 M/P\n\\] In the study by Courgeau (1973), the relationship between the intensity of migration and the number of regions in a country was examined. It was proposed that the crude migration probability (CMP) can be expressed as a function of the number of regions, denoted as ‘n’, and a constant ‘k’. \\[\n\\texttt{CMP} = k \\log (n^2)\n\\] The value of \\(k\\) in Courgeau’s formula does not have an intrinsic meaning by itself. However, it serves as a scaling factor that allows for comparisons of migration intensity across zonal systems or administrative divisions used to collect migration data. A higher value of \\(k\\) indicates a greater intensity of migration within a set of regions.\nThe migest package offers the index_intensity() function, which facilitates the calculation of migration intensity measures. This function takes migration and population totals as inputs, alongside a value for the number of regions n, and calculates both intensity measures discussed above.\n\nlibrary(migest)\nindex_intensity(mig_total = 25, pop_total = 52, n = 17)\n\n# A tibble: 2 × 2\n  measure    value\n  <chr>      <dbl>\n1 cmp        48.1 \n2 courgeau_k  8.48"
  },
  {
    "objectID": "04-indices.html#migration-distance",
    "href": "04-indices.html#migration-distance",
    "title": "\n5  Summary Migration Indices\n",
    "section": "\n5.2 Migration distance",
    "text": "5.2 Migration distance\nWhen comparing migration patterns across different regions, it is important to consider the role of distance in determining variations in the intensities of movements across space. Migration involves movements between specific locations, and the numbers and sizes of regions affect the levels of migration intensity. Thus, there are several indicies focused on the relative importance of distance within a migration system.\nMeasuring distances between regions is not always a straightforward task. Ideally, we would want to measure the typical distance that migrants travel though this information is unlikely to be available. One commonly used approximation is the straight-line distance between the region centroids of each region. Alternatively, one could could calculate the population-weighted centroid. This approach provides a better estimate of the average distances moved along a migration corridor, taking into account the spatial distribution of population within each region.\nThere are several factors that can complicate distance measurements. For example, regions located near borders may have centroids that exaggerate the actual distance between them. Regions can vary significantly in shape and size, making it challenging to capture the true distance between them. Additionally, features such as indented coastlines can create cultural and travel cost differences, impacting migration patterns.\n\n5.2.1 Creating distance matrices in R\nIn R, there are various functions available to calculate distance matrices, which can then be used to analyze migration patterns. These functions typically require a set of longitude and latitude coordinates to compute the distances between locations accurately. Some national statistics offices provide centroids for administrative areas. In situations where no centroid information is readily availble, researchers can turn to alternative sources to obtain population-weighted centroid estimates.\nThe POPGRID Data Collaborative brings together multiple research groups that publish estimates of past and future population gridded datasets. These estimates can be used to derive population-weighted centroids and facilitate the calculation of distance matrices for migration analysis.\nBelow we demonstrate how to download the population centroids from the WorldPop, one of the research groups covered by POPGRID. CSV files contain the population centriods for all first-level subregions based on the global population gridded estimates in five-year intervals between 2000 and 2020 ((Edwards2021?)). For the example below, use the 2020 CSV file from the WorldPop website and temporarily unzip the file for reading into R (i.e., the fifth file in the zip folder) using the archive_read function.\n\nlibrary(tidyverse)\nlibrary(archive)\n\n# read in data\npw <- archive_read(\n    archive = \"https://data.worldpop.org/GIS/Population_Weighted_Density/Unconstrained_Subnational/100m/PWD_100m_sub_national_CSV.zip\",\n    file = 5\n  ) %>%\n  read_csv()\n\n# view\npw\n\n# A tibble: 3,521 × 25\n    year ISO   ISO_No Country_N Adm_N GID_1 HASC  PWC_Lat PWC_Lon    Pop Density\n   <dbl> <chr>  <dbl> <chr>     <chr> <chr> <chr>   <dbl>   <dbl>  <dbl>   <dbl>\n 1  2020 RUS      643 Russia    Adyg… RUS.… RU.AD    44.8    39.8 5.13e5    66.4\n 2  2020 RUS      643 Russia    Altay RUS.… RU.AL    52.8    83.0 2.28e6    13.9\n 3  2020 RUS      643 Russia    Amur  RUS.… RU.AM    51.2   128.  7.75e5     2.2\n 4  2020 RUS      643 Russia    Arkh… RUS.… RU.AR    63.4    41.8 1.10e6     2.8\n 5  2020 RUS      643 Russia    Astr… RUS.… RU.AS    46.6    47.8 1.04e6    23.5\n 6  2020 RUS      643 Russia    Bash… RUS.… RU.BK    54.4    55.9 4.17e6    29.2\n 7  2020 RUS      643 Russia    Belg… RUS.… RU.BL    50.8    37.2 1.63e6    57.7\n 8  2020 RUS      643 Russia    Brya… RUS.… RU.BR    53.0    33.7 1.20e6    35.3\n 9  2020 RUS      643 Russia    Bury… RUS.… RU.BU    52.0   108.  9.96e5     3  \n10  2020 RUS      643 Russia    Chec… RUS.… RU.CN    43.3    45.8 1.49e6    99  \n# … with 3,511 more rows, and 14 more variables: Area <dbl>, PWD_A <dbl>,\n#   PWD_G <dbl>, PWD_M <dbl>, PWD_D1 <dbl>, PWD_D2 <dbl>, PWD_D3 <dbl>,\n#   PWD_D4 <dbl>, PWD_D5 <dbl>, PWD_D6 <dbl>, PWD_D7 <dbl>, PWD_D8 <dbl>,\n#   PWD_D9 <dbl>, PWD_D10 <dbl>\n\n\nFor illustration, we use data for South Korea to demonstrate how calculate a populated weighted distance matrix.\n\nkor_pw <- pw %>%\n  filter(ISO == \"KOR\") %>%\n  select(Adm_N, PWC_Lat, PWC_Lon, Pop)\n\nkor_pw\n\n# A tibble: 17 × 4\n   Adm_N             PWC_Lat PWC_Lon      Pop\n   <chr>               <dbl>   <dbl>    <dbl>\n 1 Busan                35.2    129.  2925666\n 2 Chungcheongbuk-do    36.7    128.  1629527\n 3 Chungcheongnam-do    36.7    127.  2049544\n 4 Daegu                35.8    129.  2098338\n 5 Daejeon              36.3    127.  1595088\n 6 Gangwon-do           37.7    128.  1446914\n 7 Gwangju              35.2    127.  1396761\n 8 Gyeonggi-do          37.4    127. 15014585\n 9 Gyeongsangbuk-do     36.1    129.  2805942\n10 Gyeongsangnam-do     35.2    129.  3444121\n11 Incheon              37.4    127.  2964572\n12 Jeju                 33.4    127.   564353\n13 Jeollabuk-do         35.8    127.  1641019\n14 Jeollanam-do         34.9    127.  1703339\n15 Sejong               36.5    127.    61443\n16 Seoul                37.5    127.  8889778\n17 Ulsan                35.5    129.  1038185\n\n\nThe calculation of distances between centroids are calculated using the distm() function from the geosphere package. By providing the longitude and latitude coordinates of the centroids, the function can estimate the distances in meters.\n\nlibrary(geosphere)\nkor_dist_pw <- kor_pw %>%\n  select(PWC_Lon, PWC_Lat) %>%\n  distm()\n\nTo enhance the usability of the distance matrix, you can add the names of the origin and destination regions to the rows and columns of the matrix using the dimnames() function. Additionally, the distances can be divided by 1000 to convert them from meters to kilometers. These manipulations allow you to easily combine the distance matrix with migration data to perform further analyses.\n\ndimnames(kor_dist_pw) <- list(orig = kor_pw$Adm_N, dest = kor_pw$Adm_N)\nkor_dist_pw <- round(kor_dist_pw/1000)\nkor_dist_pw\n\n                   dest\norig                Busan Chungcheongbuk-do Chungcheongnam-do Daegu Daejeon\n  Busan                 0               216               255    88     201\n  Chungcheongbuk-do   216                 0                58   130      45\n  Chungcheongnam-do   255                58                 0   174      54\n  Daegu                88               130               174     0     122\n  Daejeon             201                45                54   122       0\n  Gangwon-do          286               122               159   203     166\n  Gwangju             202               184               170   175     139\n  Gyeonggi-do         312                96                83   225     125\n  Gyeongsangbuk-do    107               125               176    32     128\n  Gyeongsangnam-do     43               190               222    72     168\n  Incheon             328               111                85   242     134\n  Jeju                306               381               368   333     337\n  Jeollabuk-do        201               111                96   143      66\n  Jeollanam-do        190               205               197   177     162\n  Sejong              222                37                34   141      22\n  Seoul               324               108                95   236     138\n  Ulsan                47               203               250    76     198\n                   dest\norig                Gangwon-do Gwangju Gyeonggi-do Gyeongsangbuk-do\n  Busan                    286     202         312              107\n  Chungcheongbuk-do        122     184          96              125\n  Chungcheongnam-do        159     170          83              176\n  Daegu                    203     175         225               32\n  Daejeon                  166     139         125              128\n  Gangwon-do                 0     305         114              179\n  Gwangju                  305       0         252              202\n  Gyeonggi-do              114     252           0              215\n  Gyeongsangbuk-do         179     202         215                0\n  Gyeongsangnam-do         275     159         285              101\n  Incheon                  137     253          24              234\n  Jeju                     500     199         451              365\n  Jeollabuk-do             232      75         178              161\n  Jeollanam-do             325      31         279              207\n  Sejong                   155     155         104              143\n  Seoul                    113     265          13              226\n  Ulsan                    255     229         296               81\n                   dest\norig                Gyeongsangnam-do Incheon Jeju Jeollabuk-do Jeollanam-do\n  Busan                           43     328  306          201          190\n  Chungcheongbuk-do              190     111  381          111          205\n  Chungcheongnam-do              222      85  368           96          197\n  Daegu                           72     242  333          143          177\n  Daejeon                        168     134  337           66          162\n  Gangwon-do                     275     137  500          232          325\n  Gwangju                        159     253  199           75           31\n  Gyeonggi-do                    285      24  451          178          279\n  Gyeongsangbuk-do               101     234  365          161          207\n  Gyeongsangnam-do                 0     299  277          160          148\n  Incheon                        299       0  450          180          281\n  Jeju                           277     450    0          275          176\n  Jeollabuk-do                   160     180  275            0          101\n  Jeollanam-do                   148     281  176          101            0\n  Sejong                         190     112  353           79          179\n  Seoul                          298      25  464          191          292\n  Ulsan                           76     314  351          212          222\n                   dest\norig                Sejong Seoul Ulsan\n  Busan                222   324    47\n  Chungcheongbuk-do     37   108   203\n  Chungcheongnam-do     34    95   250\n  Daegu                141   236    76\n  Daejeon               22   138   198\n  Gangwon-do           155   113   255\n  Gwangju              155   265   229\n  Gyeonggi-do          104    13   296\n  Gyeongsangbuk-do     143   226    81\n  Gyeongsangnam-do     190   298    76\n  Incheon              112    25   314\n  Jeju                 353   464   351\n  Jeollabuk-do          79   191   212\n  Jeollanam-do         179   292   222\n  Sejong                 0   117   216\n  Seoul                117     0   307\n  Ulsan                216   307     0\n\n\n\n5.2.2 Migration Distance Measures\nTo capture the average migration distance and account for the skewed distribution of distances, various methods can be employed. One approach is to calculate the weighted average of migration counts, where distances between regions serve as weights. This provides a summary measure of the average migration distance, taking into account the distances between origin and destination pairs.\n(Bell2002?) suggests that the median average distance is preferable to the mean average distance due to the negatively skewed distribution of distances. This skewness reflects the distance decay effect. Comparing the median and mean average distances can provide insights into the degree of skewness in the distributions.\nTo address skewness and model the relationship between migration counts and distances, a more comprehensive method involves fitting a predictive model. Different models can be utilized, often incorporating a log-transformed distance term and categorical control variables for the origin and destination regions. For example, a Poisson log-linear model can be employed, where the logarithm of the migration count (\\(m_{ij}\\)) is related to the origin, destination, and log-distance as follows:\n\\[\n\\log(m_{ij}) = \\beta_0 + \\beta_{1i} \\texttt{origin} + \\beta_{2j} \\texttt{destination} + \\beta_{3} \\log(\\texttt{distance})\n\\]\nThe parameter of interest in this equation is the distance decay parameter (\\(\\beta_3\\)), which indicates the impact of distance on migration. The distance decay parameter is typically negative, implying that an increase in distance leads to a decrease in predicted migration. The set of parameters \\(\\beta_{1i}\\) and \\(\\beta_{2j}\\) represent the push and pull factors specific to each region, capturing the factors influencing migration behavior.\n\n5.2.3 Migration Distance Measures in R\nThe migest package in R provides the index_distance() function, which allows you to calculate three summary distance measures based on a set of migration flows and corresponding distance values between each origin and destination.\nTo use the function, you can provide the origin-destination migration flows as either a matrix or a data frame. If using a data frame, the variable names are expected to be orig, dest, and flow. However, you have the flexibility to specify different variable names using the orig_col, dest_col, and flow_col arguments.\nSimilarly, the distance values can be provided as a matrix or data frame. The variable names in the distance data are assumed to be orig, dest, and dist. Just like with migration flows, you can customize the variable names using the appropriate arguments.\nIt is important to note that the origin and destination names in both the migration data and the distance data must match for accurate calculations. In cases where within-region migration moves are present in the data, the index_distance() function will automatically exclude them from the distance calculations.\nTo demonstrate, we use internal migration data between first-level administrative districts in South Korea provided in the korea_reg data frame in migest. The data covers migration flows between 2012 and 2020 and was published by the Korean Statistical Information Service (KOSIS) at https://kosis.kr/eng.\n\n# 2020 migration data\nkor_mig_2020 <- korea_reg %>%\n  filter(year == 2020)\n\n# check no differences in names used in migration and distance data sets\nsymdiff(x = unique(kor_mig_2020$orig), y = kor_pw$Adm_N)\n\ncharacter(0)\n\nindex_distance(m = kor_mig_2020, d = kor_dist_pw)\n\n# A tibble: 3 × 2\n  measure   value\n  <chr>     <dbl>\n1 mean    105.   \n2 median   68.7  \n3 decay    -0.852"
  },
  {
    "objectID": "04-indices.html#migration-connectivity",
    "href": "04-indices.html#migration-connectivity",
    "title": "\n5  Summary Migration Indices\n",
    "section": "\n5.3 Migration connectivity",
    "text": "5.3 Migration connectivity\nThe size of migration flows between different migration corridors is influenced by various factors beyond population size and distance. The spatial patterns of migration also reflect historical, cultural, social, and economic ties between places. Connectivity indices are used to measure how destinations or origins are linked to other places. Often measures of inequality are used — connectivity can be thought of as type of inequality in the sense that low inequality means high connectivity and high inequality means low connectivity. For example, places that receive migrants from many places may experience higher levels of migration or more stable flows, whereas places that receive migrants from a few places may be susceptible by sudden increases or decreases in migrants due to changing economic, political or environmental conditions in the origin regions.\n(Bell2002?) describes a fragmentation in the literature on the measurement of connections within a migration system, leading to the use of different terms such as spatial connectivity, spatial concentration, spatial inequality, and spatial focusing, among others. These terms highlight the importance of migration connections and the different perspectives from which they have be studied.\nTo explore and analyze migration connectivity, there are numerous indices available. The migration.indices package, for instance, provides a range of indices that capture different dimensions of migration connectivity.\nConnectivity can be analysed using five measures: connectivity, inequality, Gini coefficients, spatial focusing, and coefficient of variation. These measures capture different aspects of the overall concentration of migration flows in a system, whilst two of the measures also offer extended perspectives on the concentration in-migration and out-migration flow totals.\n\nConnectivity measures compares the proportions of migration to each region.\nInequality measures examine the distribution of migration flows across regions, in comparison to expected migration flows.\nGini coefficients, commonly used in economic inequality analysis, measure the concentration or dispersion of migration flows among regions.\nSpatial focusing measures identify the extent to which migration is concentrated or dispersed, indicating the level of spatial clustering or scattering of migrants across regions.\nCoefficient of variation measures the variability or diversity of migration flows across regions, providing insights into the heterogeneity of migration patterns.\n\nThe index_connectivity() function in the migest package offers 11 different measures that capture various aspects of migration connectivity from these five groups. To calculate the measures, a user can provide a matrix or data frame containing the migration flows as input to the function. If using a data frame, the function assumes that the flows are specified in a column with the name “flow.” However, if your data frame uses a different variable name for the flows, you can specify it using the “flow_col” argument.\n\nindex_connectivity(m = kor_mig_2020)\n\n# A tibble: 11 × 2\n   measure                  value\n   <chr>                    <dbl>\n 1 connectivity            1     \n 2 inequality_equal        0.541 \n 3 inequality_sim          0.281 \n 4 gini_total              0.709 \n 5 gini_orig_standardized  0.0493\n 6 gini_dest_standardized  0.0517\n 7 mwg_orig                0.0370\n 8 mwg_dest                0.0389\n 9 mwg_mean                0.0379\n10 cv                     17.9   \n11 acv                     3.43  \n\n\n\n5.3.1 Connectivity\nThe simplest connectivity (connectivity in the output above) evaluates the proportion of non-zero migration flows, excluding within-region flows. This measure is particularly useful when dealing with regions where populations are relatively small, which is more common when there are many administrative units. For the South Korea data used above, all migration corridors had non-zero migration flows during 2020\n\n5.3.2 Inequality\nThe inequality measures discussed by Bell (2002) are based on the distribution of observed flows compared to the expected distribution. The inequality_equal measure quantifies the distance between the observed flows and an expected distribution where all flows are equal. The inequality_sim measure quantifies the distance between the observed flows and an expected distribution derived from a spatial interaction model, such as a Poisson regression model for an independence fit.\n\\[\n\\widehat{\\log(m_{ij})} = \\beta_0 + \\beta_{1i} \\texttt{origin} + \\beta_{2j} \\texttt{destination}\n\\]\nBoth inequality measures range from 0 to 1, where a value of 0 indicates that the observed flows match the expected values, suggesting some form of equality, while a value of 1 represents the maximum distance between the observed flows and the expected flows, indicating maximum inequality in the distribution of migration flows.\n\n5.3.3 Gini measures\nThe Gini migration measures provide insights into the spatial focusing of a migration system, assessing the extent to which migration flows are concentrated in specific corridors compared to others. They are calculated by comparing each flow in the migration matrix with every other flow to determine the degree of spatial focusing.\nThe gini_total measure quantifies the overall spatial focusing in the migration flows. A value of zero indicates an equal distribution of flows across all corridors, indicating no spatial focusing. On the other hand, a value of 1 indicates maximum spatial focusing, where migration is concentrated in a single corridor.\nIn addition to the gini_total measure, the gini_orig_standardized and gini_dest_standardized values provide insights into the spatial focusing from the perspectives of origin and destination regions, respectively. These measures compare the outflows from each origin region or the inflows to each destination region, respectively, to assess the spatial concentration of the migration patterns.\n\n5.3.4 Spatial Focusing\nThe migration weighted Gini indexes specifically mwg_orig and mwg_dest, offer measures of focusing for the total in-migration and out-migration, respectively. , Also proposed by (Bell2002?), these indexes assess the degree to which migration flows are concentrated in specific origins or destinations. A value of zero indicates no spatial focusing, while a value of 1 suggests that all migration flows pass through a single origin or destination.\nAdditionally, the mwg_mean measure provides a system-wide measure of focusing for all migration totals. It is calculated as a simple average of mwg_orig and mwg_dest. Similar to the other Gini measures, the mwg_mean value ranges between zero and 1, with zero indicating no spatial focusing and 1 indicating a high concentration of migration in a single origin or destination.\n\n5.3.5 Coefficient of Variation\nThe coefficient of variation (cv in the output from the index_connectivity() function above), as proposed by (Rogers1998?), is a measure provided by the function that compares the mean of migration flows to the standard deviation of those flows. Unlike some of the previous measures, the coefficient of variation is not limited to a range of 0 to 1. It provides a quantitative measure of the variability in migration flows, where a higher coefficient of variation indicates greater inequality in the flows.\nIn addition to the coefficient of variation, the aggregated system-wide coefficient of variation (Rogers1998?) calculates a similar measure of variation but based on the aggregate coefficient of variations of in-migration and out-migration totals. It takes into account the means and standard deviations of the total in-migration and out-migration flows. Similar to the cv measure, the acv (in the output from the index_connectivity() function above) is not restricted to a range of 0 to 1. It is particularly useful for making comparisons across different time periods or countries, as a rising coefficient of variation would indicate increasing inequality in migration flows or flow totals."
  },
  {
    "objectID": "04-indices.html#migration-impact",
    "href": "04-indices.html#migration-impact",
    "title": "\n5  Summary Migration Indices\n",
    "section": "\n5.4 Migration impact",
    "text": "5.4 Migration impact\nMigration impact measures are used to assess the degree to which migration contributes to the transformation of human settlement patterns. In many regions around the world, migration has become or is becoming the predominant mechanism driving population change and redistribution. Descriptive studies often concentrate on examining net migration counts at the regional level, which reveal whether migration adds or subtracts people from the overall population. However, as noted before, changes in migration volumes and may not always be revealed in net migration counts.\nAdditional measures exist to provide a more comprehensive summary of the overall effect of migration in redistributing populations across the entire system of regions. These measures take into account not only the net migration totals but also the gross migration flows in or out of regions. By considering the complete migration picture, these measures offer insights into the broader impact of migration on population redistribution.\n\n5.4.1 Migration effectiveness index\nThe migration effectiveness index (MEI), introduced by (Shryock1976?), evaluates the asymmetry or equilibrium in a migration network by calculating the ratio of net migration to migration turnover. The MEI is calculated by taking the absolute sum of net migration and dividing it by the sum of in-migration plus out-migration, multiplied by 100.\n\\[\n\\texttt{MEI} = 100 \\frac{\\sum_{i} | \\texttt{net} |}{\\sum_{i} \\texttt{turnover}_i} = 100 \\frac{\\sum_{i} | m_{+i} - m_{i+}|}{\\sum_{i} m_{+i} + m_{i+}}\n\\]\nThe MEI ranges between 0 and 100. Higher values of the MEI indicate that migration is an efficient mechanism for population redistribution, as reflected by large net migration totals relative to the overall turnover. In other words, a higher MEI suggests that migration plays a significant role in reshaping the population distribution within the network.\nConversely, values closer to zero are generated from more balanced migration systems with less pronounced population redistribution. A lower MEI indicates a relatively equitable distribution of migration flows, where the net migration values are smaller in relation to the turnover.\n\n5.4.2 Aggregate net migration rate\nThe aggregate net migration rate (ANMR), proposed by (Bell2002?), captures the overall effect of migration on population settlement patterns. It is derived from the migration net totals and the populations of regions within a country. The ANMR replaces the denominator of the MEI formula with the population of each region, denoted as \\(P_i\\).\n\\[\n\\texttt{ANMR} = 100 \\frac{1}{2} \\frac{\\sum_{i} |\\texttt{net}_i|}{\\sum_{i} P_i} = 100 \\frac{1}{2} \\frac{\\sum_{i} | m_{+i} - m_{i+} |}{\\sum_{i} P_i}\n\\]\nThe ANMR represents the net shift of population between regions per 100 residents in the country. Unlike the MEI, which uses migration turnover in the denominator, the ANMR utilizes the population of each region. This allows for a measurement of the net migration effect relative to the size of the population in each region.\nThe ANMR has no upper limit, as it depends on the net migration values and the population sizes of the regions. A higher ANMR indicates a larger net shift of population between regions, relative to the overall population size in the country. It reflects the magnitude of population redistribution resulting from migration.\nAdditionally, the ANMR can be seen as the product of the migration connectivity index (CMI) and the migration effectiveness index (MEI). It combines the measures of connectivity and effectiveness to provide an overall assessment of the impact of migration on population settlement patterns.\n\n5.4.3 Preference and velocity\nThe manual by the (UnitedNations1983?) introduces two other impact measures for migration, although these measures have become less commonly used in recent years.\nThe preference index is derived from an expected model of migration interactions based on population shares and the overall level of migration. It compares the observed migration flows (\\(m_{ij}\\)) to an expected model where migration rates in all populations are the same.\n\\[\n\\texttt{preference} = \\sum_{ij}{\\frac{m_{ij}}{m_{++} \\frac{p_{i}}{p_+}\\frac{p_{j}}{p_+}}}\n\\]\nwhere \\(m_{++}\\) is the total migration flow, \\(p_{+}\\) is the sum of populations in each region, and \\(p_i\\) and \\(p_j\\) are the population sizes of the origin and destination regions, respectively. The preference index measures the extent to which the observed flows deviate from the expected flows based on population shares and overall migration levels. There is no upper limit to the preference index.\nThe velocity index, on the other hand, is based on a migration velocity measure (\\(\\frac{m_{ij}}{p_{i} p_{j}}\\)) multiplied by the total population and summed over all migration flows. It compares the observed flows to an expected model where flow sizes are determined solely by the population sizes of the origin and destination regions.\n\\[\n\\texttt{velocity}  = \\sum_{ij}{\\frac{m_{ij}}{p_{i} p_{j}}{p_+}}\n\\]\nSimilar to the preference index, the velocity index has no upper limit.\nBoth the preference index and the velocity index provide measures of the deviation of observed migration flows from the expected patterns based on population sizes and overall migration levels. They offer alternative perspectives on the impact of migration on population redistribution, focusing on the relative significance of observed flows compared to expectations based on population factors alone.\n\n5.4.4 Migration Impact Measures in R\nThe index_impact() function in the migest package allows for the calculation of all four impact measures: preference index, velocity index, migration effectiveness index (MEI), and aggregate net migration rate (ANMR). This function requires a set of migration flows and population sizes in each region.\nAs with the previous index functions in the migest package, the migration flows can be provided as a matrix or a data frame. The function assumes that the column names for the regions and population values provided to the p argument are region and pop, respectively, in a data frame. If your data frame has different column names, you can specify them using the reg_col and pop_col parameters. In the code below we use the population estimates from the WorldPop group provided in the Pop column of the kor_pw ojbect created earlier.\n\nindex_impact(m = kor_mig_2020, p = kor_pw, pop_col = \"Pop\", reg_col = \"Adm_N\")\n\n# A tibble: 4 × 2\n  measure        value\n  <chr>          <dbl>\n1 effectivness   7.67 \n2 anmr           0.379\n3 preference   916.   \n4 velocity      45.3"
  },
  {
    "objectID": "04-indices.html#applying-index-functions-multiple-times",
    "href": "04-indices.html#applying-index-functions-multiple-times",
    "title": "\n5  Summary Migration Indices\n",
    "section": "\n5.5 Applying index functions multiple times",
    "text": "5.5 Applying index functions multiple times\nSome of the summary measures discussed above are meaningless on their own, as they have no relative scale and have been calculated in isolation. However, the index functions can be applied to compare migration systems across different areas or time periods relatively easily using R, enabling comparative analyses.\nTo apply the index functions multiple times, you can loop over the countries or time periods of interest and apply the functions within the loop. Alternatively, you can use vectorized operations or apply functions from the dplyr or purrr packages to handle multiple countries or time periods efficiently.\nTo demonstrate the application of the index functions in the migest package, we can use the korea_reg data of internal migration flows between 2012 and 2020 in South Korea. First we use the group_nest() function from the dplyr package which transforms the data frame into a grouped data frame based on the year column, which is a necessary step for applying the index functions. Once the data is grouped, we can then apply the index_connectivity() function to each row using the map() function from the purrr package. This will calculate the connectivity measures for each year in the korea_reg data set. We may set long = FALSE within the index_connectivity() function to allow for separate columns for each measure. These can be viewed over time using the unnest() function in the tidyr package\n\nd <- korea_reg %>%\n  filter(orig != dest) %>%\n  group_nest(year, .key = \"mig_data\") %>%\n  mutate(connectivity = map(.x = mig_data, .f = ~index_connectivity(.x, long = FALSE)))\nd\n\n# A tibble: 9 × 3\n   year           mig_data connectivity     \n  <int> <list<tibble[,3]>> <list>           \n1  2012          [272 × 3] <tibble [1 × 11]>\n2  2013          [272 × 3] <tibble [1 × 11]>\n3  2014          [272 × 3] <tibble [1 × 11]>\n4  2015          [272 × 3] <tibble [1 × 11]>\n5  2016          [272 × 3] <tibble [1 × 11]>\n6  2017          [272 × 3] <tibble [1 × 11]>\n7  2018          [272 × 3] <tibble [1 × 11]>\n8  2019          [272 × 3] <tibble [1 × 11]>\n9  2020          [272 × 3] <tibble [1 × 11]>\n\nd %>%\n  unnest(connectivity)\n\n# A tibble: 9 × 13\n   year         mig_data conne…¹ inequ…² inequ…³ gini_…⁴ gini_…⁵ gini_…⁶ mwg_o…⁷\n  <int> <list<tibble[,3>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1  2012        [272 × 3]       1   0.554   0.266   0.718  0.0500  0.0498  0.0380\n2  2013        [272 × 3]       1   0.552   0.270   0.717  0.0501  0.0499  0.0381\n3  2014        [272 × 3]       1   0.542   0.282   0.707  0.0507  0.0495  0.0380\n4  2015        [272 × 3]       1   0.537   0.284   0.703  0.0509  0.0496  0.0378\n5  2016        [272 × 3]       1   0.541   0.277   0.707  0.0505  0.0502  0.0376\n6  2017        [272 × 3]       1   0.538   0.285   0.703  0.0502  0.0506  0.0374\n7  2018        [272 × 3]       1   0.541   0.281   0.707  0.0497  0.0511  0.0370\n8  2019        [272 × 3]       1   0.537   0.280   0.703  0.0493  0.0514  0.0366\n9  2020        [272 × 3]       1   0.541   0.281   0.709  0.0493  0.0517  0.0370\n# … with 4 more variables: mwg_dest <dbl>, mwg_mean <dbl>, cv <dbl>, acv <dbl>,\n#   and abbreviated variable names ¹​connectivity, ²​inequality_equal,\n#   ³​inequality_sim, ⁴​gini_total, ⁵​gini_orig_standardized,\n#   ⁶​gini_dest_standardized, ⁷​mwg_orig\n\n\nThis approach allows for easy comparison and analysis of migration systems between different areas or time periods. For example, we can see that connectivity measures such as the inequality_equal and gini_total showed a decreases after initial higher values during 2012 and 2013 in the proceeding seven years from 2014 to 2020.\nWe can use similar code to calculate the distance indices.\n\nd <- d %>%\n  mutate(distance = map(.x = mig_data, .f = ~index_distance(m = .x, d = kor_dist_pw, long = FALSE)))\n\nd %>%\n  select(year, distance) %>%\n  unnest(distance)\n\n# A tibble: 9 × 4\n   year  mean median  decay\n  <int> <dbl>  <dbl>  <dbl>\n1  2012  108.   76   -0.784\n2  2013  107.   76   -0.795\n3  2014  108.   76   -0.816\n4  2015  108.   76   -0.828\n5  2016  107.   76   -0.820\n6  2017  108.   75.8 -0.839\n7  2018  107.   74.8 -0.839\n8  2019  107.   75.8 -0.836\n9  2020  105.   68.7 -0.852\n\n\nThe measures illustrate a decline in the mean and median distances over the nine years, whilst the distance decay parameter increases - again implying declining shorter migration distances.\nThe impact and intensity measures require additional data on populatino sizes, which are provided in the korea_pop data frame in the migest package. These can be added to the data frame of the index calculations.\n\n# add population data\nd <- korea_pop %>%\n  group_nest(year, .key = \"pop_data\") %>%\n  right_join(d, by = \"year\")\nd\n\n# A tibble: 9 × 5\n   year           pop_data           mig_data connectivity      distance        \n  <int> <list<tibble[,2]>> <list<tibble[,3]>> <list>            <list>          \n1  2012           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n2  2013           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n3  2014           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n4  2015           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n5  2016           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n6  2017           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n7  2018           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n8  2019           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n9  2020           [17 × 2]          [272 × 3] <tibble [1 × 11]> <tibble [1 × 3]>\n\n\nTwo data sets in each year can be passed to the index_impact() function using the map2() function in the purrr package\n\nd <- d %>%\n  mutate(impact = map2(.x = mig_data, .y = pop_data, \n                       .f = ~index_impact(m = .x, p = .y, pop_col = \"population\", long = FALSE)))\n\nThe intensity measures require only the migration and population totals in each year. These can be calculated by summing the appropriate columns in each data frame and passing the totals to the index_intensity() function\n\n# calculate migration and population totals for intensity measure\nd <- d %>%\n  mutate(mig_total = map_dbl(.x = mig_data, .f = ~sum(.x$flow)),\n         pop_total = map_dbl(.x = pop_data, .f = ~sum(.x$population)),\n         intensity = map2(.x = mig_total, .y = pop_total, \n                          .f = ~index_intensity(mig_total = .x, pop_total = .y, n = 17, long = FALSE)))\n\nd %>%\n  select(year, contains(\"total\"), intensity) %>%\n  unnest(intensity)\n\n# A tibble: 9 × 5\n   year mig_total pop_total   cmp courgeau_k\n  <int>     <dbl>     <dbl> <dbl>      <dbl>\n1  2012   2512740  50948272  4.93      0.870\n2  2013   2423429  51141463  4.74      0.836\n3  2014   2507796  51327916  4.89      0.862\n4  2015   2551424  51529338  4.95      0.874\n5  2016   2453342  51696216  4.75      0.838\n6  2017   2410930  51778544  4.66      0.822\n7  2018   2429184  51826059  4.69      0.827\n8  2019   2384948  51849861  4.60      0.812\n9  2020   2534114  51829023  4.89      0.863\n\n\nIn the case of South Korea, there does not appear to be a general trend for either intensity measure over the nine year period."
  },
  {
    "objectID": "05-age.html#rogers-castro-migration-age-schedules",
    "href": "05-age.html#rogers-castro-migration-age-schedules",
    "title": "\n6  Migration Age Schedules\n",
    "section": "\n6.1 Rogers Castro migration age schedules",
    "text": "6.1 Rogers Castro migration age schedules\nAs with other demographic events such as fertility and mortality, migration exhibit consistent patterns in their age-specific rates. Demographers have dedicated efforts to capturing and summarizing these regularities in rates using mathematical expressions known as model schedules. These model schedules aim to provide a concise representation of the age-specific migration rates based on empirical data.\nModel migration age schedules are used for several purposes in demographic analysis and population studies. They commonly provide a basis for projecting and forecasting future migration patterns in cohort component population projection models. This can be to smooth age-specific migration baseline data which might be unreliable. When no age-specific migration data is available, model migration age schedules can be used to derive age-specific migration patterns required for cohort component population projection models. Fitted parameters in model migration age schedules can also be used to analyze and compare the age-specific migration patterns in different populations, identifying similarities and differences.\n(Rogers1981?) were the first to identify and mathematically summarise the consistency in migraiton age patterns after a comprehensive analysis of more than 500 age profiles of migration. Rogers-Castro migration age schedule are composed of intersecting mathematical curves representing migration patterns across different life stages. The curves in different parts of the schedule aims to capture the age-specific migration rates within specific segments of the population. The schedules are divided into five main components:\n\nPre-labor force: This curve represents migration patterns among individuals who have not yet entered the labor force, such as children, students or young individuals who have not yet started working. Higher migration rates tend to found in very young adolescents who move with their parents.\nLabor force: This curve focuses on migration patterns among individuals who are actively engaged in the labor force. It captures migration behavior among working-age individuals, reflecting factors such as job opportunities, economic conditions, and career advancements which tend to peak in early adulthood and then gradually decline until retiremnet.\nPost-labor force: This curve accounts for migration patterns among individuals who have exited the labor force, such as retirees. Upon exiting the labour force, indivudals might migrate as they no longer need to be located near their working location.\nPost-retirement: This component specifically addresses migration patterns among individuals who are towards the later stages of their life course and might migrate for better access to healthcare and proximity to family or social networks for later life care.\nConstant term: This term represents a constant or baseline level of migration that is independent of age.\n\nEach of these componets can be represented mathematically using algebraic expression for cureves describing the changes in migration rates \\(m\\) for each age group \\(x\\) and combined as:\n\\[\n\\begin{aligned}\nm(x) =& a_1 \\exp(-\\alpha_1 x)  \\\\\n&+a_2 \\exp(-\\alpha_2(x - \\mu_2) - \\exp(\\lambda_2(x - \\mu_2)))  \\\\\n&+a_3 \\exp(-\\alpha_3(x - \\mu_3) - \\exp(\\lambda_3(x - \\mu_3)))  \\\\\n&+a_4 \\exp(\\lambda_4x)\\\\\n&+ c\n\\end{aligned}\n\\]\nBy combining the components, the Rogers-Castro migration age schedules provide a framework for describing age-specific migration patterns across different life stages. In many locations and time periods, not all of the components of the full migration age schedule are relevant.\nAlmost all migration age patterns exhibit certain a downward slope during the pre-labor force years and a peak during the labor force period. To capture these patterns, only a 7-parameter model schedule, without the additional algebraic expressions for the post-labour and post-retirement components (based on the \\(a3, a4, \\alpha_3, \\mu_3, \\lambda_3 and \\lambda_4\\)$) are used.\nIn specific areas, particularly in more elderly Western countries, migration age patterns may exhibit the additional retirement peak components, which leads to an 11-parameter model schedule that includes the pre-labor force and labor force components. In contrast, in some regions, instead of a retirement peak, age profiles exhibit an upward slope towards the end of life, which leads to a 9-parameter model schedule. In rare cases, there are instances where both a retirement peak and a post-retirement upward slope are observed in migration age patterns, captured by the full 13-parameter model schedule, proposed by (Rogers1987a?). Further refinements to the migration model age schedules have since been proposed, including by (Wilson2010?), who introduced a 17-parameter model that incorporates a student peak before the labor force peak. This addition acknowledges the migration patterns observed among students, who may migrate for educational purposes before entering the labor force.\nThe mig_calculate_rc() function in the rcbayes package by (Alexander2021?) provide a quick method to calculate migration age schedules for a given parameter set\n\nlibrary(tidyverse)\nlibrary(rcbayes)\n# define 7 parameters\np &lt;- c(a1 = 0.1, alpha1 = 0.1, \n       a2 = 0.2, alpha2 = 0.1, mu2 = 20, lambda2 = 0.5, \n       c = 0.01)\n\n# calculate model migration schedule with 11 parameters\nmx &lt;- mig_calculate_rc(ages = 1:100, pars = p)\n# first 10 mx\nmx[1:10]\n\n [1] 0.10048374 0.09187308 0.08408182 0.07703200 0.07065307 0.06488116\n [7] 0.05965853 0.05493290 0.05065697 0.04678794\n\n# plot the calculated  mx\ntibble(x = 1:100, \n       mx = mx) %&gt;%\n  ggplot(mapping = aes(x = x, y = mx)) +\n  geom_line()"
  },
  {
    "objectID": "05-age.html#model-migration-age-schedules",
    "href": "05-age.html#model-migration-age-schedules",
    "title": "\n6  Migration Age Schedules\n",
    "section": "\n6.2 Model migration age schedules",
    "text": "6.2 Model migration age schedules\nModel migration schedules play a crucial role in situations where age-specific migration data is unavailable but necessary. One such scenario is in cohort component projections, where age-specific migration rates are essential but might not be readily accessible due to the lack of statistical infrastructure to monitor detailed migration patterns.\nTo overcome this challenge, researchers can utilize model migration schedules as a practical solution. By leveraging an estimate or reported data on total migration and adopting a model age schedule it becomes possible to derive age-specific migration rates using a standardized form of the age schedule to dissagregate the totals. The selection process of the model age schedule involves the careful selection based on existing knowledge of migration age patterns for the specific population or flow under investigation.\nThe migest package includes the rc_model_fund data frame with a set of fundamental parameters proposed by (Rogers1981?), designed to represent a typical migration age pattern from their analysis. Containing only seven parameters, they do not include additional curves for the post-labor force phase and post-retirement peak. We can use the deframe() function to convert the data frame rc_model_fund into an named vector for use in the mig_calculate_rc() to calculate the age specific migration rates for a given set of ages\n\nlibrary(migest)\nrc_model_fund\n\n# A tibble: 7 × 2\n  param    value\n  &lt;chr&gt;    &lt;dbl&gt;\n1 a1       0.02 \n2 alpha1   0.1  \n3 a2       0.06 \n4 alpha2   0.1  \n5 mu2     20    \n6 lambda2  0.4  \n7 c        0.003\n\n# convert data frame to named vector\np &lt;- deframe(rc_model_fund)\np\n\n     a1  alpha1      a2  alpha2     mu2 lambda2       c \n  2e-02   1e-01   6e-02   1e-01   2e+01   4e-01   3e-03 \n\n# calculate and plot age schedule based on fundamental parameters \ntibble(x = 1:80, \n       mx = mig_calculate_rc(ages = x, pars = p)) %&gt;%\n  ggplot(mapping = aes(x = x, y = mx)) +\n  geom_line()\n\n\n\n\nThe (UnitedNations1992?) proposed a number of alternative sets of parameter values to seven-parameter model age schedules in settings outside of the Western-country populations used by (Rogers1981?) when designing their fundamental parameter set. These parameters are provided in the rc_model_un data frame\n\nrc_model_un\n\n# A tibble: 84 × 5\n   schedule         schedule_abb sex   param     value\n   &lt;chr&gt;            &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Western standard ws           male  a1       0.0215\n 2 Western standard ws           male  alpha1   0.105 \n 3 Western standard ws           male  a2       0.0694\n 4 Western standard ws           male  alpha2   0.112 \n 5 Western standard ws           male  mu2     20.0   \n 6 Western standard ws           male  lambda2  0.391 \n 7 Western standard ws           male  c        0.0028\n 8 Low dependency   ld           male  a1       0.0128\n 9 Low dependency   ld           male  alpha1   0.105 \n10 Low dependency   ld           male  a2       0.0804\n# … with 74 more rows\n\n\nTo apply the parameters to the mig_calculate_rc() function we can use the nest() function to group together the parameters into separate tibbles by sex and population settings.\n\nd &lt;- rc_model_un %&gt;%\n  select(-schedule_abb) %&gt;%\n  nest(rc_param = c(param, value)) %&gt;%\n  mutate(p = map(.x = rc_param, .f = ~deframe(.x)),\n         mx = map(.x = p, \n                  .f = ~mig_calculate_rc(ages = 1:80, pars = .x)),\n         age = list(1:80))\nd\n\n# A tibble: 12 × 6\n   schedule                              sex    rc_param p         mx     age   \n   &lt;chr&gt;                                 &lt;chr&gt;  &lt;list&gt;   &lt;list&gt;    &lt;list&gt; &lt;list&gt;\n 1 Western standard                      male   &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 2 Low dependency                        male   &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 3 High dependency                       male   &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 4 Young labour force entry              male   &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 5 Old labour force entry                male   &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 6 Low dependency low labour force entry male   &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 7 Western standard                      female &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 8 Low dependency                        female &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n 9 High dependency                       female &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n10 Young labour force entry              female &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n11 Old labour force entry                female &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n12 Low dependency low labour force entry female &lt;tibble&gt; &lt;dbl [7]&gt; &lt;dbl&gt;  &lt;int&gt; \n\n\nOnce we have used the map() function to estimate the model migration age schedules for ages 1 to 80 using the mig_calculate_rc() function we create a data base varying by age for each model schedule and sex for plotting to get a better idea of how each migraiton schedule operates for each sex and population\n\nd %&gt;%\n  unnest(c(mx, age)) %&gt;%\n  mutate(schedule = str_wrap(schedule, width = 20)) %&gt;%\n  ggplot(mapping = aes(x = age, y = mx, colour = schedule)) +\n  geom_line() +\n  facet_wrap(facets = \"sex\", ncol = 1)\n\n\n\n\nNotable from the plot is the later peak age of migration in the older labour force entry age schedules, compared to the Western Standard age schedule that has parameters very close to those proposed by (Rogers1981?). For populations with younger labour force entry the peak age of migration shifts leftwards, whilst it increases for populations with low old age dependencies and decreases populations with high old age dependencies.\nIt is worth noting again, that the typical use of model age schedules might be when we do not know any age-specific migration rates but soley a migration total, where the migration total might be a projected or forecasted value. In such a case we might first select an appropriate model schedule from rc_model_un\n\n# example for males based on young labour force entry\np &lt;- rc_model_un %&gt;%\n  filter(sex == \"male\", schedule_abb == \"ylfe\") %&gt;%\n  select(param, value) %&gt;%\n  deframe()\np\n\n     a1  alpha1      a2  alpha2     mu2 lambda2       c \n 0.0215  0.1050  0.0691  0.1120 16.0900  0.3910  0.0028 \n\n\nWe may then calculate the age-specific migration using the parameter values to generate a standardized model age schedule (where the calculated \\(m(x)\\) values sum to one) using the mig_calculate_rc() function. The standardized values can the be multiplied by a total estimate to get the age-specific migration counts, which might be converted to rates given the appropriate denominator.\n\ntibble(x = 1:90, \n       mx = mig_calculate_rc(ages = x, pars = p),\n       # calculate number of migrants, given a total estimate of 10,000\n       Mx = 10000 * mx) %&gt;%\n  ggplot(mapping = aes(x = x, y = Mx)) +\n  geom_line()"
  },
  {
    "objectID": "05-age.html#fitting-roger-castro-migration-age-schedules",
    "href": "05-age.html#fitting-roger-castro-migration-age-schedules",
    "title": "\n6  Migration Age Schedules\n",
    "section": "\n6.3 Fitting Roger Castro migration age schedules",
    "text": "6.3 Fitting Roger Castro migration age schedules\nWhen we have age-specific migration data, we may be interested in estimating the parameters of a Rogers Castro age schedule. Estimating these parameters serves several purposes:\n\nSmoothing the data: By fitting a Rogers Castro age schedule to age-specific migration data, we can obtain a smoothed representation of the migration pattern. This can help in reducing the noise in the data that might be generated from difficulties in collecting data on the number of migrants entering or leaving a region or country.\nComparing parameter estimates: Estimating the parameters of a Rogers Castro age schedule allows us to compare migration patterns between different time periods or migration streams. By examining the differences in parameter estimates, we can gain insights into changes or variations in the age-specific migration patterns. We will further explore the interpretation of parameter estimates of the Rogers-Castro fitted age schedules in the next section.\nCreating age schedules for projected migration: Once we have estimated the parameters of the age schedule, we can use these estimates to project future migration patterns based on past patterns of the age schedule parameters or using the smoothed values from the fitted model migration age schedule.\n\nFitting Rogers Castro migration age schedules has long be a difficult challenge due to the relatively small amount of data (based on the number age groups) and the relatively complexity of the migration age schedules. Various code and software tools have been used including FORTAN code in (Rogers1994?), the TableCurve 2D software (Rogers1999a?), MATLAB code used by (Rogers2010?), and VBA code for Excel (Wilson2010?). Three alternative linear parameter estimation methods were provided by (Rogers2005?)\nFortunately, the rcbayes package provides a mig_estimate_rc() function that provides far better performance and flexibility than its predecessors. The mig_estimate_rc() function calls Stan, a Bayesian probabilistic programming language, via the rstan package, to estimate the parameters of a Rogers Castro age schedule. The estimation process is performed using a powerful Bayesian sampling techniques to estimate the of parameter in a range of Rogers-Castro migration age schedules and their full posterior distributions to quantify the uncertainty of the estimates.\nTo use the mig_estimate_rc() function, two arguments are required:\n\n\nages: A vector of migration ages, representing the age groups for which we have migration data.\n\nmx: A vector of standardized migration intensities corresponding to the ages in the ages vector. or\n\nmigrants and pop: Two vectors of migrant and population counts to calculate the age specific migration rates.\n\nAdditionally, the form of the age schedule can be specified using the pre_working_age, working_age, retirement, and post_retirement arguments, which can be set to TRUE or FALSE depending on the desired structure of the age schedule.\nTo demonstrate we will use data for immigration age-specific immigration flows into Cyprus during 2011 published by Eurostat. These can be downloaded using the eurostat package:\n\nlibrary(eurostat)\n# all age-sex specific immigration data\nimm &lt;- get_eurostat(id = \"migr_imm8\")\n\n# filter to cyprus 2011\nimm_cy_2011 &lt;- imm %&gt;%\n  filter(geo == \"CY\",\n         age != \"TOTAL\",\n         age != \"UNK\",\n         sex != \"T\",\n         time == \"2011-01-01\")\n\n# format age column to numeric values\nimm_cy_2011 &lt;- imm_cy_2011 %&gt;%\n  mutate(\n    age = str_remove(string = age, pattern = \"Y\"),\n    age = case_when(\n      age == \"_LT1\" ~ \"0\",\n      age == \"_GE100\" ~ \"101\",\n      TRUE ~ age\n    ), \n    age = as.numeric(age)\n  )\nimm_cy_2011 \n\n# A tibble: 162 × 7\n   agedef   age unit  sex   geo   time       values\n   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt;      &lt;dbl&gt;\n 1 REACH      1 NR    F     CY    2011-01-01    130\n 2 REACH      1 NR    M     CY    2011-01-01    136\n 3 REACH     10 NR    F     CY    2011-01-01     88\n 4 REACH     10 NR    M     CY    2011-01-01    102\n 5 REACH     11 NR    F     CY    2011-01-01     97\n 6 REACH     11 NR    M     CY    2011-01-01     89\n 7 REACH     12 NR    F     CY    2011-01-01     89\n 8 REACH     12 NR    M     CY    2011-01-01     79\n 9 REACH     13 NR    F     CY    2011-01-01     65\n10 REACH     13 NR    M     CY    2011-01-01     73\n# … with 152 more rows\n\n\nWe can see that the data do appear to not entirely smooth. This may be due to random variations in migration patterns of relatively small counts of migration. However, it would not be ideal to use the raw data as underlying assumption for the distribution of age-specific migration in a cohort component population projection model as there is clear justification for believing the underlying age migration patterns are non-smooth. For example, to observed migration for 41 year old persons is slightly higher that those that are 40 years old and counter to the declining trend of migration from 30 year old onwards.\n\nimm_cy_2011 %&gt;%\n  ggplot(mapping = aes(x = age, y = values, colour = sex)) +\n  geom_line() +\n  geom_point()\n\n\n\n\nThe general shape of the observed values indicate that a seven parameter Rogers Castro migration age schedules is appropriate, where is no retirement peak or post-retirement slope are visable.\nThe mx values required in the mig_estimate_rc() function represent the standardized migration intensities corresponding to the ages in the ages vector, meaning that their sum should be equal to one. This ensures that the migration intensities are properly scaled and reflect the relative proportions of migration within each age group.\nWhen using the mig_estimate_rc() function, it is common to wait for a few minutes during the computation time. Additionally, the function may print out several messages from Stan, with information about the estimation process, including the progress of the MCMC sampling and any convergence diagnostics.\nIt is recommended to carefully review the messages printed during the estimation process to ensure that the estimation has converged properly and that the results are reliable. The messages can provide insights into the estimation process and help identify any potential issues or concerns.\n\n# standardize migration intensity\nimm_cy_2011 &lt;- imm_cy_2011 %&gt;%\n  group_by(sex) %&gt;%\n  mutate(mx = values/sum(values)) \nimm_cy_2011\n\n# A tibble: 162 × 8\n# Groups:   sex [2]\n   agedef   age unit  sex   geo   time       values      mx\n   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n 1 REACH      1 NR    F     CY    2011-01-01    130 0.0102 \n 2 REACH      1 NR    M     CY    2011-01-01    136 0.0132 \n 3 REACH     10 NR    F     CY    2011-01-01     88 0.00693\n 4 REACH     10 NR    M     CY    2011-01-01    102 0.00987\n 5 REACH     11 NR    F     CY    2011-01-01     97 0.00763\n 6 REACH     11 NR    M     CY    2011-01-01     89 0.00862\n 7 REACH     12 NR    F     CY    2011-01-01     89 0.00700\n 8 REACH     12 NR    M     CY    2011-01-01     79 0.00765\n 9 REACH     13 NR    F     CY    2011-01-01     65 0.00512\n10 REACH     13 NR    M     CY    2011-01-01     73 0.00707\n# … with 152 more rows\n\n# fit seven-parameter rogers castro \nf_cy_male &lt;- mig_estimate_rc(ages = imm_cy_2011 %&gt;%\n                       filter(sex == \"M\") %&gt;%\n                       pull(age), \n                     mx = imm_cy_2011 %&gt;%\n                       filter(sex == \"M\") %&gt;%\n                       pull(mx),\n                     pre_working_age = TRUE, working_age = TRUE,\n                     retirement = FALSE, post_retirement = FALSE)\n\nmig_estimate_rc is running normal model, Using arguments ages and mx\n\n\n\nSAMPLING FOR MODEL 'rcmodel_normal' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 2.346 seconds (Warm-up)\nChain 1:                1.817 seconds (Sampling)\nChain 1:                4.163 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'rcmodel_normal' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 2: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 2.339 seconds (Warm-up)\nChain 2:                2.475 seconds (Sampling)\nChain 2:                4.814 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'rcmodel_normal' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 0 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 3: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 2.862 seconds (Warm-up)\nChain 3:                2.469 seconds (Sampling)\nChain 3:                5.331 seconds (Total)\nChain 3: \n\nSAMPLING FOR MODEL 'rcmodel_normal' NOW (CHAIN 4).\nChain 4: \nChain 4: Gradient evaluation took 0 seconds\nChain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 4: Adjust your expectations accordingly!\nChain 4: \nChain 4: \nChain 4: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 4: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 4: \nChain 4:  Elapsed Time: 2.919 seconds (Warm-up)\nChain 4:                2.365 seconds (Sampling)\nChain 4:                5.284 seconds (Total)\nChain 4: \n\n\nThe mig_estimate_rc() function returns a list object with three components. In the output of the mig_estimate_rc() function, there are three elements:\n\npars_df: This is a data frame that contains the parameter estimates along with their 95% credible intervals. The parameter estimates represent the values obtained from the estimation process, while the credible intervals provide a measure of uncertainty around those estimates.\nfit_df: This is a data frame that shows the original data and the estimated migration rates at each age.\ncheck_converge: This is a data frame that provides information about the convergence of the estimation process. It includes the R-hat values and effective sample sizes for each parameter. The R-hat values, also known as the Gelman-Rubin statistic, assess the convergence of the MCMC chains used in the estimation. A value close to 1 indicates good convergence. The effective sample sizes indicate the number of independent samples obtained for each parameter, and higher values indicate more reliable estimates.\n\n\n# parameter estimates\nf_cy_male$pars_df\n\n# A tibble: 7 × 4\n  variable    median      lower    upper\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1 a1        0.0119    0.0100     0.0137 \n2 a2        0.0591    0.0535     0.0674 \n3 alpha1    0.0446    0.0286     0.0682 \n4 alpha2    0.0776    0.0681     0.0924 \n5 c         0.000599  0.0000267  0.00181\n6 lambda2   0.295     0.235      0.358  \n7 mu2      21.1      20.5       22.0    \n\n# fitted schedule\nf_cy_male$fit_df\n\n# A tibble: 81 × 6\n     age    data  median   lower   upper       diff_sq\n   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;         &lt;dbl&gt;\n 1     1 0.0132  0.0120  0.0106  0.0135  0.00000137   \n 2    10 0.00987 0.00822 0.00725 0.00911 0.00000273   \n 3    11 0.00862 0.00789 0.00687 0.00881 0.000000528  \n 4    12 0.00765 0.00758 0.00651 0.00854 0.00000000473\n 5    13 0.00707 0.00729 0.00619 0.00828 0.0000000478 \n 6    14 0.00687 0.00704 0.00595 0.00806 0.0000000294 \n 7    15 0.00552 0.00701 0.00596 0.00805 0.00000223   \n 8    16 0.00823 0.00752 0.00642 0.00879 0.000000503  \n 9    17 0.00629 0.00917 0.00781 0.0108  0.00000829   \n10    18 0.0149  0.0123  0.0106  0.0141  0.00000665   \n# … with 71 more rows\n\n# plot of observed and fitted age schedule with 95% credible interval\nggplot(data = f_cy_male$fit_df, \n       mapping = aes(x = age, y = data)) +\n  geom_ribbon(mapping = aes(ymin = lower, ymax = upper), fill = \"lightblue\") +\n  geom_line(mapping = aes(y = median), colour = \"blue\") +\n  geom_point()"
  },
  {
    "objectID": "05-age.html#smoothing",
    "href": "05-age.html#smoothing",
    "title": "\n6  Migration Age Schedules\n",
    "section": "\n6.4 Smoothing",
    "text": "6.4 Smoothing\nThere are many non-parametric smoothing functions that can applied to age-specific migration data to help capturing the underlying patterns by reducing noise and variability in the data. Some commonly used smoothing functions in R are available in the stats package, which is loaded by default when R opens. They can fitted very quickly in comparison to Rogers-Castro model age schedules and do not require any specification on the phases.\nSmoothing methods involve weighting data points within specific subsections or windows of the data. These methods typically employ local regression or averaging techniques to estimate migration intensities at each age based on the data from neighboring ages.\nChoosing an appropriate bandwidth or window size is crucial in smoothing age-specific migration data. The bandwidth determines the range of nearby ages considered for each estimation and influences the level of smoothing applied. The default bandwidth values for the smoothing functions in R might not always be suitable for migration age schedules, as the underlying patterns and variability can vary across different contexts and the smoothing functions are more typically applied to much larger data sets (as opposed to 100 or so age groups in the age-specific migration data).\nIn some cases, it may be necessary to censor or exclude the very oldest age groups from the smoothing process. This is because migration intensities for these age groups can become volatile and unreliable due to small numbers of migrants. By removing these extreme values, the smoothing methods can provide more stable and meaningful estimates of migration patterns across the age range.\nAn example of the unevenness in observed age-specific migration data can be found in the ipumsi_age data frame of the migest package. The data in the object are based on census samples from Brazil 2000 and France 2006 published in the IPUMS International repository ((ipums2015?)). The data frame contains a variable migrants on the population weighted counts of persons who migrated between any minor (and major) administrative units determined from responses to questions on place of residence five-years prior to the census. The migration intensities are particularly uneven at the elderly age groups in the sample from the Brazil 2000 census.\n\nipumsi_age %&gt;%\n  mutate(mi = migrants/population) %&gt;%\n  filter(age &gt; 5) %&gt;%\n  ggplot(mapping = aes(x = age, y = mi)) +\n  geom_point() +\n  geom_line() +\n  facet_wrap(facets = \"sample\", scales = \"free\")\n\n\n\n\nMost smoothing functions in R typically require two vectors: x and y. The x vector represents the independent variable, such as age, and the y vector represents the dependent variable, such as migration intensity. These functions often have optional arguments that allow you to control the smoothness of the fit, although the names of these arguments may vary depending on the specific smoothing function.\nWhen applying a smoothing function, it will return a list with two components: x and y. It’s important to note that the length of the x vector may differ from the original vector provided. To control the output length, some smoothing functions offer arguments (with different names depending on the function) that allow you to specify the desired length of the output. The x component of the output will match the age values, while the y component will represent the smoothed values of the dependent variable.\n\n6.4.1 Kernal Smoothing\nThe ksmooth() function in the stats package performs kernel regression smoothing. It estimates a smooth curve by applying a kernel weighting to nearby data points, allowing for flexible and localized smoothing. To demonstrate we will use the migration intensities calculated from the Brazil 2000 IPUMS International sample provided in the ipums_age data frame. Note, there are no intensities for ages below five as the question on previous place of residence five-years prior to the census was not applicable for the sub population.\n\nbra_2000 &lt;- ipumsi_age %&gt;%\n  filter(sample == \"BRA2000\",\n         age &gt; 5) %&gt;%\n  mutate(mi = migrants/population)\nbra_2000\n\n# A tibble: 95 × 5\n   sample    age migrants population     mi\n   &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 BRA2000     6  355723.   3311728. 0.107 \n 2 BRA2000     7  343852.   3307567. 0.104 \n 3 BRA2000     8  327166.   3258046. 0.100 \n 4 BRA2000     9  314905.   3272305. 0.0962\n 5 BRA2000    10  324066.   3345583. 0.0969\n 6 BRA2000    11  329525.   3451739. 0.0955\n 7 BRA2000    12  327113.   3518160. 0.0930\n 8 BRA2000    13  323180.   3473133. 0.0931\n 9 BRA2000    14  334783.   3566239. 0.0939\n10 BRA2000    15  337297.   3528845. 0.0956\n# … with 85 more rows\n\n\nWe can use the n.points argument in the ksmooth() function to fix the length of the smoothed points returned by the object.\n\n# default returns 100 values. corresponding ages in x no longer integers\nk1 &lt;- ksmooth(x = bra_2000$age, y = bra_2000$mi)\nstr(k1)\n\nList of 2\n $ x: num [1:100] 6 6.95 7.9 8.85 9.8 ...\n $ y: num [1:100] 0.1074 0.104 0.1004 0.0962 0.0969 ...\n\n# return only 95 values to match the number of age groups in the data\nk2 &lt;- ksmooth(x = bra_2000$age, y = bra_2000$mi, n.points = nrow(bra_2000))\nstr(k2)\n\nList of 2\n $ x: num [1:95] 6 7 8 9 10 11 12 13 14 15 ...\n $ y: num [1:95] 0.1074 0.104 0.1004 0.0962 0.0969 ...\n\n\nThe ksmooth() function is unlikely to smooth a migration age schedule as the default bandwidth parameter is too small for one hundred odd age groups. The bandwidth parameter can be increased to provide a more suitable fit\n\nbra_2000 &lt;- bra_2000 %&gt;% \n  mutate(\n    k_default = ksmooth(x = age, y = mi, n.points = n())$y,\n    k_5 = ksmooth(x = age, y = mi, n.points = n(), bandwidth = 5)$y,\n    k_10 = ksmooth(x = age, y = mi, n.points = n(), bandwidth = 10)$y\n  )\nbra_2000\n\n# A tibble: 95 × 8\n   sample    age migrants population     mi k_default    k_5   k_10\n   &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 BRA2000     6  355723.   3311728. 0.107     0.107  0.104  0.100 \n 2 BRA2000     7  343852.   3307567. 0.104     0.104  0.102  0.0990\n 3 BRA2000     8  327166.   3258046. 0.100     0.100  0.101  0.0983\n 4 BRA2000     9  314905.   3272305. 0.0962    0.0962 0.0986 0.0978\n 5 BRA2000    10  324066.   3345583. 0.0969    0.0969 0.0964 0.0976\n 6 BRA2000    11  329525.   3451739. 0.0955    0.0955 0.0949 0.0978\n 7 BRA2000    12  327113.   3518160. 0.0930    0.0930 0.0944 0.0975\n 8 BRA2000    13  323180.   3473133. 0.0931    0.0931 0.0942 0.0982\n 9 BRA2000    14  334783.   3566239. 0.0939    0.0939 0.0950 0.100 \n10 BRA2000    15  337297.   3528845. 0.0956    0.0956 0.0973 0.103 \n# … with 85 more rows\n\nbra_2000 %&gt;%\n  pivot_longer(cols = contains(\"k_\"), names_to = \"bandwidth\", names_prefix = \"k_\") %&gt;%\n  ggplot(mapping = aes(x = age, y = value, colour = bandwidth)) +\n  geom_point(mapping = aes(y = mi), alpha = 0.5) +\n  geom_line() +\n  scale_colour_brewer(palette = \"Set1\")\n\n\n\n\n\n6.4.2 Loess Smoothing\nThe stats package also contains another smoothing function; loess.smooth(), which carries out local polynomial regression fitting. It fits a smooth curve to the data using a weighted least squares approach, with the degree of smoothing controlled by a span tuning parameter. The loess.smooth() function, similar to the ksmooth() function, may not be suitable for smoothing a migration age schedule using the default parameters. The default value of the span parameter, which controls the smoothness of the fit, is often too large for applying to migration age schedules. Additionally, the evaluation parameter specifies the number of predicted values by default as 50.\n\nbra_2000 &lt;- bra_2000 %&gt;%\n  mutate(\n    lo_default = loess.smooth(x = age, y = mi, evaluation = n())$y,\n    lo_2 = loess.smooth(x = age, y = mi, evaluation = n(), span = 0.2)$y,\n    lo_1 = loess.smooth(x = age, y = mi, evaluation = n(), span = 0.1)$y,\n  )\n\nbra_2000 %&gt;%\n  pivot_longer(cols = contains(\"lo_\"), names_to = \"span\", names_prefix = \"lo_\") %&gt;%\n  ggplot(mapping = aes(x = age, y = value, colour = span)) +\n  geom_point(mapping = aes(y = mi), alpha = 0.5) +\n  geom_line() +\n  scale_colour_brewer(palette = \"Set1\")\n\n\n\n\n\n6.4.3 Cubic Spline smoothing\nCubic spline smoothing is another popular method for smoothing data, including migration age schedules. It provides a flexible and smooth curve by connecting cubic polynomials between data points. In R, the smooth.spline() function in the stats package can be used to perform cubic spline smoothing. The function allows you to control the smoothness of the fit using the spar parameter (between 0 and 1), which determines the amount of smoothing applied. A smaller spar value results in a smoother fit, while a larger value allows for more flexibility and potential for capturing local variations in the data. The number of predicted smoothed\n\nbra_2000 &lt;- bra_2000 %&gt;%\n  mutate(\n    s_default = smooth.spline(x = age, y = mi, n = n())$y,\n    s_6 = smooth.spline(x = age, y = mi, n = n(), spar = 0.6)$y,\n    s_8 = smooth.spline(x = age, y = mi, n = n(), spar = 0.8)$y\n  )\n\nbra_2000 %&gt;%\n  pivot_longer(cols = contains(\"s_\"), names_to = \"spar\", names_prefix = \"s_\") %&gt;%\n  ggplot(mapping = aes(x = age, y = value, colour = spar)) +\n  geom_point(mapping = aes(y = mi), alpha = 0.5) +\n  geom_line() +\n  scale_colour_brewer(palette = \"Set1\")\n\n\n\n\nAs with each of the earlier smoothing methods, it’s important to experiment with smoothing parameter (spar, span in loess.smooth() and bandwidth in ksmooth()) to evaluate the resulting smoothed migration age schedule visually to determine the optimal level of smoothing for your requirements."
  },
  {
    "objectID": "05-age.html#graduating",
    "href": "05-age.html#graduating",
    "title": "\n6  Migration Age Schedules\n",
    "section": "\n6.5 Graduating",
    "text": "6.5 Graduating\nWhen faced with migration data reported in age groups instead of single-year data, graduating methods can be employed to estimate migration for each individual age. These methods aim to distribute the reported age group totals across the corresponding ages in a way that maintains consistency and ensures that the graduated values sum up to the reported totals.\nOne useful tool for performing the graduation process is the graduate() function in the DemoTools package. While originally designed for interpolating population totals, it is also suitable for estimating migration flows. The function offers several graduating methods, each with its own approach and assumptions. For a comprehensive understanding of these methods, you can refer to the guide provided here.\nTo utilize the graduate() function, you need to provide the reported values (Value) and specify the minimum age (Age) for which the data is available. Additionally, for certain methods like pclm, you can specify the maximum value for the final open age group if it exists. By applying the appropriate graduating method, you can obtain estimates of migration for each individual year based on the available age group data.\nTo demonstrate we will use internal migration data in Italy contained in the italy_area data set in the migest package. In particular we will use the age-specific out migration counts from the Islands regions, which can be derived from using the sum_region() function\n\nita_reg &lt;- italy_area %&gt;%\n  group_by(year, age_grp) %&gt;%\n  sum_region() %&gt;%\n  separate(col = \"age_grp\", into = c(\"age_min\", \"age_max\"), convert = TRUE)\nita_reg\n\n# A tibble: 700 × 8\n# Groups:   year [7]\n    year age_min age_max region     out_mig in_mig  turn   net\n   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  1970       0       4 Center        5634   8087 13721  2453\n 2  1970       0       4 Islands       7876   4532 12408 -3344\n 3  1970       0       4 North-East    4973   5760 10733   787\n 4  1970       0       4 North-West   11777  18873 30650  7096\n 5  1970       0       4 South        15422   8430 23852 -6992\n 6  1970       5       9 Center        4726   7448 12174  2722\n 7  1970       5       9 Islands       7271   3592 10863 -3679\n 8  1970       5       9 North-East    4172   5327  9499  1155\n 9  1970       5       9 North-West    9530  17719 27249  8189\n10  1970       5       9 South        14745   6358 21103 -8387\n# … with 690 more rows\n\nisl_1970 &lt;- ita_reg %&gt;%\n  filter(year == 1970,\n         region == \"Islands\")\n\nWhen we apply the pclm method we tell the graduate() function that the last age group is open and set a new maximum value of 100.\n\n# # install devtools from CRAN\n# install.packages(\"devtools\")\n# # install DemoTools from github\n# devtools::install_github(\"timriffe/DemoTools\")\nlibrary(DemoTools)\n\nLoading required package: Rcpp\n\n\n\nAttaching package: 'DemoTools'\n\n\nThe following objects are masked from 'package:rcbayes':\n\n    mig_calculate_rc, mig_estimate_rc\n\ng &lt;- graduate(Value = isl_1970$out_mig, Age = isl_1970$age_min,\n              method = \"pclm\", OAG =  TRUE, OAnew = 100)\ng\n\n          0           1           2           3           4           5 \n1540.822616 1563.081967 1582.487050 1594.810184 1594.859870 1576.283303 \n          6           7           8           9          10          11 \n1534.233098 1470.025351 1388.679355 1301.771896 1221.108012 1158.023181 \n         12          13          14          15          16          17 \n1121.942083 1119.554144 1158.435391 1247.103598 1398.284195 1623.913611 \n         18          19          20          21          22          23 \n1935.092918 2321.755623 2741.539266 3112.329630 3324.796748 3324.915552 \n         24          25          26          27          28          29 \n3125.320990 2812.139216 2482.216694 2189.772149 1958.656025 1781.415216 \n         30          31          32          33          34          35 \n1641.408137 1521.553492 1407.170481 1293.744997 1182.104397 1077.109503 \n         36          37          38          39          40          41 \n 984.353885  906.668010  845.151088  798.771354  765.545510  742.411329 \n         42          43          44          45          46          47 \n 725.616964  710.186702  690.289756  660.651697  617.401802  562.289211 \n         48          49          50          51          52          53 \n 501.033932  441.541294  391.355174  354.054434  330.929904  320.470746 \n         54          55          56          57          58          59 \n 319.333087  323.280116  326.437894  324.340533  314.694694  298.140366 \n         60          61          62          63          64          65 \n 278.157544  258.006157  240.321118  226.037262  214.561457  204.846583 \n         66          67          68          69          70          71 \n 195.376275  185.304981  174.609045  163.809589  153.997862  145.822900 \n         72          73          74          75          76          77 \n 139.398446  134.182156  128.693201  121.517548  111.497757   98.816336 \n         78          79          80          81          82          83 \n  85.271323   72.734621   62.959243   56.411258   52.462550   49.962470 \n         84          85          86          87          88          89 \n  46.549791   40.446619   31.418669   21.471299   13.559411    8.503983 \n         90          91          92          93          94          95 \n   5.890223    4.961916    5.352577    7.481251   12.438906   21.715730 \n         96          97          98          99         100 \n  32.832828   36.073090   26.875823   13.368895    4.891892 \n\n\nWhen we plot the observed age schedule besides the graduated age schedule we see the drop in the relative scales of the single-year data, which are constrained to match the observed five-year out-migraiton totals.\n\nlibrary(patchwork)\np1 &lt;- ggplot(data = isl_1970,\n       mapping = aes(x = age_min + 2.5, y = out_mig)) +\n  geom_point()\n\np2 &lt;- tibble(age = 0:100, mx = g) %&gt;%\n  ggplot(mapping = aes(x = age, y = mx)) +\n  geom_line()\n\np1 + p2\n\n\n\n\nThe graduation of the five-year migration counts to single-year counts can be seen by inspecting the sum of the first five estimated values in the g object and the obeseverd data for the out migration of the 0-4 year olds.\n\n# 0-4\nsum(g[1:5])\n# 5-9\nsum(g[6:10])\n\nisl_1970"
  },
  {
    "objectID": "05-age.html#migraiton-age-indices",
    "href": "05-age.html#migraiton-age-indices",
    "title": "\n6  Migration Age Schedules\n",
    "section": "\n6.6 Migraiton Age Indices",
    "text": "6.6 Migraiton Age Indices\nIndex measures for age-specific migration schedules can be used to summarizing and comparing migration age profiles. They provide a concise representation of age-specific migration rates, enabling researchers to identify distinctive features and variations in the age dynamics of migration patterns across populations or over time.\nThere are two main families of index measures for migration age schedules. The first uses relationships between fitted parameters of a Rogers-Castro migration age schedules. The second uses empirical measures based on either the observed or smoothed age-specific migration data.\n\n6.6.1 Rogers and Castro Parameter Relationships\n(Rogers1981?) highlighted the significance of the relationships between certain parameters in the model age schedules. These relationships can provide insights into important characteristics of migration patterns and can guide the derivation of customized model schedules. Four key measures, namely peaking, dominance, labor asymmetry, and regularity, were highlighted.\nPeaking refers to the timing of the peak migration age, indicating whether migration rates peak at an earlier or later age. In the fundamental parameters proposed by Rogers and Castro, the parameter \\(\\mu_2\\) is set to 20, representing a age where with the highest migration rates.\nDominance, is captured by the relationship \\(\\gamma_{12} = a_1/a_2\\), which represents the ratio of migration rates between two specific age groups. It serves as an index of child dependency in the migration age patterns, with the inverse \\(1/\\gamma_{12}\\) reflecting the index of labor dominance. In the fundamental parameters, \\(\\gamma_{12} = 1/3\\).\nLabor asymmetry is measured by the relationship \\(\\sigma_2 = \\lambda_2/\\alpha_2\\), representing the ratio of two parameters used for the upward and downward parts of the labour force curve in the age schedule. In the fundamental parameters, \\(\\sigma_2 = 4\\) indicating a faster (by four times) rise in the curve before the peak than the decline after the peak.\nFinally, regularity is assessed through the relationship \\(\\beta_{12} = \\alpha_1/\\alpha_2\\), which compares the migration rates of parents and children. A value of \\(\\beta_{12} = 1\\), as in the fundamental parameters, indicates a regular pattern where the migration rates of children closely match those of their parents.\nThe index_age_rc() function in the migest package returns these ratios given a named vector of the parameters. For example, we can see the disussed values in the fundamental parameters:\n\nrc_model_fund %&gt;%\n  deframe() %&gt;%\n  index_age_rc()\n\n# A tibble: 5 × 2\n  measure           value\n  &lt;chr&gt;             &lt;dbl&gt;\n1 peaking          20    \n2 child_dependency  0.333\n3 labor_dependency  3    \n4 labor_asymmetry   4    \n5 regularity        1    \n\n\nMore practically, we can also compare migration age schedules using the relationships between the parameter estimates. To demonstrate we fit a Rogers-Castro migration age schedule for female immigrants to Cyprus during 2011:\n\nf_cy_female &lt;- mig_estimate_rc(ages = imm_cy_2011 %&gt;%\n                       filter(sex == \"F\") %&gt;%\n                       pull(age), \n                     mx = imm_cy_2011 %&gt;%\n                       filter(sex == \"F\") %&gt;%\n                       pull(mx),\n                     pre_working_age = TRUE, working_age = TRUE,\n                     retirement = FALSE, post_retirement = FALSE)\n\n\nSAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0.000102 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.02 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 1.558 seconds (Warm-up)\nChain 1:                1.109 seconds (Sampling)\nChain 1:                2.667 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 6.1e-05 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.61 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 2: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 1.517 seconds (Warm-up)\nChain 2:                1.237 seconds (Sampling)\nChain 2:                2.754 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 4.5e-05 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.45 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 3: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 1.471 seconds (Warm-up)\nChain 3:                1.092 seconds (Sampling)\nChain 3:                2.563 seconds (Total)\nChain 3: \n\nSAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4).\nChain 4: \nChain 4: Gradient evaluation took 4.6e-05 seconds\nChain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.46 seconds.\nChain 4: Adjust your expectations accordingly!\nChain 4: \nChain 4: \nChain 4: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 4: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 4: \nChain 4:  Elapsed Time: 1.553 seconds (Warm-up)\nChain 4:                1.32 seconds (Sampling)\nChain 4:                2.873 seconds (Total)\nChain 4: \n\n\nWe can then combine the parameter estimates for the male and female fitted Rogers-Castro migration age schedules and apply the index_age_rc() function:\n\ntibble(\n  sex = c(\"male\", \"female\"),\n  p = list(f_cy_male$pars_df %&gt;%\n             select(variable, median) %&gt;%\n             deframe(),\n           f_cy_female$pars_df %&gt;%\n             select(variable, median) %&gt;%\n             deframe())\n) %&gt;%\n  mutate(rc_index = map(.x = p, .f = ~index_age_rc(pars = .x, long = FALSE))) %&gt;%\n  unnest(cols = rc_index)\n\n# A tibble: 2 × 7\n  sex    p         peaking child_dependency labor_dependency labor_asy…¹ regul…²\n  &lt;chr&gt;  &lt;list&gt;      &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n1 male   &lt;dbl [7]&gt;    21.1            0.201             4.98        3.80   0.574\n2 female &lt;dbl [7]&gt;    24.1            0.127             7.85        1.91   0.573\n# … with abbreviated variable names ¹​labor_asymmetry, ²​regularity\n\n\nThe calculations indicate a later peak age and lower levels of asymmetry in the female immigration flows compared to the male counterparts.\n\n6.6.2 Emprical Age Indices\nModel age schedules for migration have faced several criticisms, see for example (Bell2002?) or (Bernard2014?). One significant challenge is the lack of consensus on the appropriate number of parameters to include in a model schedule. Different model forms can yield varying parameter estimates, making comparisons across studies or time periods challenging. To address this issue, statistical accuracy measures are sometimes used to select the best model form, although this can risk overfitting the data.\nAnother concern is the sensitivity of parameter estimates to the choice of initial values. However, when using the mig_estimate_rc() function, this issue is mitigated as the estimation process relies on MCMC sampling which discards the first few thousand iterations in the estimation procedure. Unstable parameter estimates in Roger-Castro migration age schedules can arise due to measurement error in age-specific migration data. This instability can affect the reliability and robustness of the estimated parameters, making it challenging to draw firm conclusions from the results. Furthermore, the interpretation of parameter estimates, particularly the indexes in index_age_rc(), has not been widely adopted. This is likely due to the difficulty in fitting model schedules accurately, resulting in skepticism regarding the practical usefulness of these indexes.\nSeveral alternative measures of age-specific migration have been proposed that do not involve fitting model age schedules. These measures often rely on the migration intensity, which is the number of migrants in a specific age group and time period as a percentage of the population at risk of moving.\nOne such measure is the Gross Migraproduction Rate (GMR) proposed by (Rogers1975?). The GMR is calculated as the sum of age-specific migration intensities, \\(m(x)\\), taking into. It provides a measure of the overall migration intensity in a given population by aggregating the migration rates across different age groups.\n\\[\n\\texttt{GMR} = \\sum_{x} m(x)\n\\]\n(Bell2002?) introduced two additional measures. The first is the peak migration intensity, which identifies the age group with the highest migration intensity. The second measure is the peak age, which corresponds to the age at which the peak migration intensity occurs (in the data rather than a fitted age scheule as used in the previous section).\n(Bell2009?) proposed additional measures to further analyze age-specific migration patterns. The first measure is the breadth of the peak, which considers the sum of the peak migration intensity at the peak age and the five age-groups before and after the peak. This measure provides insights into the width or spread of the migration peak, indicating the range of ages where migration is concentrated.\nThe second measure introduced by (Bell2009?) is the peak share, which calculates the percentage of the normalized migration age schedule covered by the peak age and the five age-groups before and after the peak. This measure provides an indication of the relative importance and concentration of migration in the peak age range compared to the entire age distribution.\n(Bernard2014?) proposed three additional measures that focus on the labor force peak. The first measure is the Maximum Upward Rate of Change (MURC), which identifies the largest gradient in the slope of the labor force peak before the peak age. This measure captures the steepest increase in migration intensity leading up to the labor force peak.\nThe second measure is the Maximum Downward Rate of Change (MDRC), which identifies the largest gradient in the slope of the labor force peak after the peak age. This measure captures the steepest decrease in migration intensity following the labor force peak.\nThe third measure introduced by Bernard (Bernard2014?) is the asymmetry of the labor force peak, which is determined by the ratio of MURC and MDRC. This measure quantifies the asymmetry or imbalance in the migration intensity before and after the peak age.\nAll of these measures, including the breadth of the peak, peak share, MURC, MDRC, and asymmetry, are calculated in the age_index() function in the migest package. (Bernard2014?) recommends smoothing age schedules before calculating the index values. However, if the data is not extremely rough then very similar calculated values will be obtained as the index_age() function ignores by default values above 65 (and below 5) when calculating peak index statistics. The one exception to the sensitivity to the smoothness in the data is the GMR which is based on all ages, where, as seen earlier in some of the eldest age groups, the observed values might be very small (oldest in Brazil).\n\nipumsi_age %&gt;%\n  filter(age &gt; 5) %&gt;%\n  mutate(mi = migrants/population) %&gt;%\n  nest(.by = sample) %&gt;%\n  mutate(index_age = map(.x = data, .f = ~index_age(d = .x, long = FALSE))) %&gt;%\n  unnest(index_age)\n\n# A tibble: 2 × 10\n  sample  data       gmr peak_mi peak_age peak_bre…¹ peak_…²  murc  mdrc asymm…³\n  &lt;chr&gt;   &lt;list&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1 BRA2000 &lt;tibble&gt;  7.71    14.3       24       143.    18.6    19    32   0.594\n2 FRA2006 &lt;tibble&gt;  9.41    29.5       26       258.    27.4    18    30   0.6  \n# … with abbreviated variable names ¹​peak_breadth, ²​peak_share, ³​asymmetry\n\n\nNotice the older peak migration intensity and ages in France 2006, where the breadth of the peak is wider a lower upward and downward rate of change."
  }
]